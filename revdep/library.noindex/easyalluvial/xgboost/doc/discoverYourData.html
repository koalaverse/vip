<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Tianqi Chen, Tong He, Michaël Benesty, Yuan Tang" />


<title>Understand your dataset with XGBoost</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
margin: 0 auto;
background-color: white;

/ font-family:Georgia, Palatino, serif;
font-family: "Open Sans", "Book Antiqua", Palatino, serif;
/ font-family:Arial, Helvetica, sans-serif;
/ font-family:Tahoma, Verdana, Geneva, sans-serif;
/ font-family:Courier, monospace;
/ font-family:"Times New Roman", Times, serif;
	color: #333333; 
/ color: #000000; 
/ color: #666666; 	/ color: #E3E3E3; 
/ color: white; line-height: 100%;
max-width: 800px;
padding: 10px;
font-size: 17px;
text-align: justify;
text-justify: inter-word;
}
p {
line-height: 150%;
/ max-width: 540px;
max-width: 960px;
margin-bottom: 5px;
font-weight: 400; / color: #333333
}
h1, h2, h3, h4, h5, h6 {
font-weight: 400;
margin-top: 35px;
margin-bottom: 15px;
padding-top: 10px;
}
h1 {
margin-top: 70px;
color: #606AAA;
font-size:230%;
font-variant:small-caps;
padding-bottom:20px;
width:100%;
border-bottom:1px solid #606AAA;
}
h2 {
font-size:160%;
}
h3 {
font-size:130%;
}
h4 {
font-size:120%;
font-variant:small-caps;
}
h5 {
font-size:120%;
}
h6 {
font-size:120%;
font-variant:small-caps;
}
a {
color: #606AAA;
margin: 0;
padding: 0;
vertical-align: baseline;
}
a:hover {
text-decoration: blink;
color: green;
}
a:visited {
color: gray;
}
ul, ol {
padding: 0;
margin: 0px 0px 0px 50px;
}
ul {
list-style-type: square;
list-style-position: inside;
}
li {
line-height:150% }
li ul, li ul {
margin-left: 24px;
}
pre {
padding: 0px 10px;
max-width: 800px;
white-space: pre-wrap;
}
code {
font-family: Consolas, Monaco, Andale Mono, monospace, courrier new;
line-height: 1.5;
font-size: 15px;
background: #F8F8F8;
border-radius: 4px;
padding: 5px;
display: inline-block;
max-width: 800px;
white-space: pre-wrap;
}
li code, p code {
background: #CDCDCD;
color: #606AAA;
padding: 0px 5px 0px 5px;
}
code.r, code.cpp {
display: block;
word-wrap: break-word;
border: 1px solid #606AAA; }
aside {
display: block;
float: right;
width: 390px;
}
blockquote {
border-left:.5em solid #606AAA;
background: #F8F8F8;
padding: 0em 1em 0em 1em;
margin-left:10px;
max-width: 500px;
}
blockquote cite {
line-height:10px;
color:#bfbfbf;
}
blockquote cite:before {
/content: '\2014 \00A0';
}
blockquote p, blockquote li { color: #666;
}
hr {
/ width: 540px;
text-align: left;
margin: 0 auto 0 0;
color: #999;
}

table {
width: 100%;
border-top: 1px solid #919699;
border-left: 1px solid #919699;
border-spacing: 0;
}
table th {
padding: 4px 8px 4px 8px;
text-align: center;
color: white;
background: #606AAA;
border-bottom: 1px solid #919699;
border-right: 1px solid #919699;
}
table th p {
font-weight: bold;
margin-bottom: 0px; }
table td {
padding: 8px;	vertical-align: top;
border-bottom: 1px solid #919699;
border-right: 1px solid #919699;
}
table td:last-child {
/background: lightgray;
text-align: right;
}
table td p {
margin-bottom: 0px; }
table td p + p {
margin-top: 5px; }
table td p + p + p {
margin-top: 5px; }
</style>




</head>

<body>




<h1 class="title toc-ignore">Understand your dataset with XGBoost</h1>
<h4 class="author">Tianqi Chen, Tong He, Michaël Benesty, Yuan Tang</h4>


<div id="TOC">
<ul>
<li><a href="#understand-your-dataset-with-xgboost" id="toc-understand-your-dataset-with-xgboost"><span class="toc-section-number">1</span> Understand your dataset with
XGBoost</a>
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1.1</span> Introduction</a></li>
<li><a href="#preparation-of-the-dataset" id="toc-preparation-of-the-dataset"><span class="toc-section-number">1.2</span> Preparation of the dataset</a>
<ul>
<li><a href="#numeric-v.s.-categorical-variables" id="toc-numeric-v.s.-categorical-variables"><span class="toc-section-number">1.2.1</span> Numeric v.s. categorical
variables</a></li>
<li><a href="#conversion-from-categorical-to-numeric-variables" id="toc-conversion-from-categorical-to-numeric-variables"><span class="toc-section-number">1.2.2</span> Conversion from categorical to
numeric variables</a></li>
</ul></li>
<li><a href="#build-the-model" id="toc-build-the-model"><span class="toc-section-number">1.3</span> Build the model</a></li>
<li><a href="#feature-importance" id="toc-feature-importance"><span class="toc-section-number">1.4</span> Feature importance</a></li>
<li><a href="#measure-feature-importance" id="toc-measure-feature-importance"><span class="toc-section-number">1.5</span> Measure feature importance</a>
<ul>
<li><a href="#build-the-feature-importance-data.table" id="toc-build-the-feature-importance-data.table"><span class="toc-section-number">1.5.1</span> Build the feature importance
data.table</a></li>
<li><a href="#plotting-the-feature-importance" id="toc-plotting-the-feature-importance"><span class="toc-section-number">1.5.2</span> Plotting the feature
importance</a></li>
<li><a href="#do-these-results-make-sense" id="toc-do-these-results-make-sense"><span class="toc-section-number">1.5.3</span> Do these results make
sense?</a></li>
</ul></li>
<li><a href="#conclusion" id="toc-conclusion"><span class="toc-section-number">1.6</span> Conclusion</a></li>
<li><a href="#special-note-what-about-random-forests" id="toc-special-note-what-about-random-forests"><span class="toc-section-number">1.7</span> Special Note: What about Random
Forests™?</a></li>
</ul></li>
</ul>
</div>

<div id="understand-your-dataset-with-xgboost" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Understand your dataset
with XGBoost</h1>
<div id="introduction" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Introduction</h2>
<p>The purpose of this vignette is to show you how to use
<strong>XGBoost</strong> to discover and understand your own dataset
better.</p>
<p>This vignette is not about predicting anything (see <a href="https://github.com/dmlc/xgboost/blob/master/R-package/vignettes/xgboostPresentation.Rmd">XGBoost
presentation</a>). We will explain how to use <strong>XGBoost</strong>
to highlight the <em>link</em> between the <em>features</em> of your
data and the <em>outcome</em>.</p>
<p>Package loading:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(xgboost)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(Matrix)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">require</span>(data.table)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">require</span>(<span class="st">&#39;vcd&#39;</span>)) <span class="fu">install.packages</span>(<span class="st">&#39;vcd&#39;</span>)</span></code></pre></div>
<blockquote>
<p><strong>VCD</strong> package is used for one of its embedded dataset
only.</p>
</blockquote>
</div>
<div id="preparation-of-the-dataset" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Preparation of the
dataset</h2>
<div id="numeric-v.s.-categorical-variables" class="section level3" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> Numeric v.s.
categorical variables</h3>
<p><strong>XGBoost</strong> manages only <code>numeric</code>
vectors.</p>
<p>What to do when you have <em>categorical</em> data?</p>
<p>A <em>categorical</em> variable has a fixed number of different
values. For instance, if a variable called <em>Colour</em> can have only
one of these three values, <em>red</em>, <em>blue</em> or
<em>green</em>, then <em>Colour</em> is a <em>categorical</em>
variable.</p>
<blockquote>
<p>In <strong>R</strong>, a <em>categorical</em> variable is called
<code>factor</code>.</p>
<p>Type <code>?factor</code> in the console for more information.</p>
</blockquote>
<p>To answer the question above we will convert <em>categorical</em>
variables to <code>numeric</code> one.</p>
</div>
<div id="conversion-from-categorical-to-numeric-variables" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Conversion from
categorical to numeric variables</h3>
<div id="looking-at-the-raw-data" class="section level4" number="1.2.2.1">
<h4><span class="header-section-number">1.2.2.1</span> Looking at the
raw data</h4>
<p>In this Vignette we will see how to transform a <em>dense</em>
<code>data.frame</code> (<em>dense</em> = few zeroes in the matrix) with
<em>categorical</em> variables to a very <em>sparse</em> matrix
(<em>sparse</em> = lots of zero in the matrix) of <code>numeric</code>
features.</p>
<p>The method we are going to see is usually called <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a>.</p>
<p>The first step is to load <code>Arthritis</code> dataset in memory
and wrap it with <code>data.table</code> package.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(Arthritis)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.table</span>(Arthritis, <span class="at">keep.rownames =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<blockquote>
<p><code>data.table</code> is 100% compliant with <strong>R</strong>
<code>data.frame</code> but its syntax is more consistent and its
performance for large dataset is <a href="https://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly">best
in class</a> (<code>dplyr</code> from <strong>R</strong> and
<code>Pandas</code> from <strong>Python</strong> <a href="https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping">included</a>).
Some parts of <strong>XGBoost</strong> <strong>R</strong> package use
<code>data.table</code>.</p>
</blockquote>
<p>The first thing we want to do is to have a look to the first few
lines of the <code>data.table</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df)</span></code></pre></div>
<pre><code>##    ID Treatment  Sex Age Improved
## 1: 57   Treated Male  27     Some
## 2: 46   Treated Male  29     None
## 3: 77   Treated Male  30     None
## 4: 17   Treated Male  32   Marked
## 5: 36   Treated Male  46   Marked
## 6: 23   Treated Male  58   Marked</code></pre>
<p>Now we will check the format of each column.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(df)</span></code></pre></div>
<pre><code>## Classes &#39;data.table&#39; and &#39;data.frame&#39;:   84 obs. of  5 variables:
##  $ ID       : int  57 46 77 17 36 23 75 39 33 55 ...
##  $ Treatment: Factor w/ 2 levels &quot;Placebo&quot;,&quot;Treated&quot;: 2 2 2 2 2 2 2 2 2 2 ...
##  $ Sex      : Factor w/ 2 levels &quot;Female&quot;,&quot;Male&quot;: 2 2 2 2 2 2 2 2 2 2 ...
##  $ Age      : int  27 29 30 32 46 58 59 59 63 63 ...
##  $ Improved : Ord.factor w/ 3 levels &quot;None&quot;&lt;&quot;Some&quot;&lt;..: 2 1 1 3 3 3 1 3 1 1 ...
##  - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt;</code></pre>
<p>2 columns have <code>factor</code> type, one has <code>ordinal</code>
type.</p>
<blockquote>
<p><code>ordinal</code> variable :</p>
<ul>
<li>can take a limited number of values (like <code>factor</code>)
;</li>
<li>these values are ordered (unlike <code>factor</code>). Here these
ordered values are: <code>Marked &gt; Some &gt; None</code></li>
</ul>
</blockquote>
</div>
<div id="creation-of-new-features-based-on-old-ones" class="section level4" number="1.2.2.2">
<h4><span class="header-section-number">1.2.2.2</span> Creation of new
features based on old ones</h4>
<p>We will add some new <em>categorical</em> features to see if it
helps.</p>
<div id="grouping-per-10-years" class="section level5" number="1.2.2.2.1">
<h5><span class="header-section-number">1.2.2.2.1</span> Grouping per 10
years</h5>
<p>For the first feature we create groups of age by rounding the real
age.</p>
<p>Note that we transform it to <code>factor</code> so the algorithm
treat these age groups as independent values.</p>
<p>Therefore, 20 is not closer to 30 than 60. To make it short, the
distance between ages is lost in this transformation.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df[,<span class="at">AgeDiscret :=</span> <span class="fu">as.factor</span>(<span class="fu">round</span>(Age<span class="sc">/</span><span class="dv">10</span>,<span class="dv">0</span>))])</span></code></pre></div>
<pre><code>##    ID Treatment  Sex Age Improved AgeDiscret
## 1: 57   Treated Male  27     Some          3
## 2: 46   Treated Male  29     None          3
## 3: 77   Treated Male  30     None          3
## 4: 17   Treated Male  32   Marked          3
## 5: 36   Treated Male  46   Marked          5
## 6: 23   Treated Male  58   Marked          6</code></pre>
</div>
<div id="random-split-into-two-groups" class="section level5" number="1.2.2.2.2">
<h5><span class="header-section-number">1.2.2.2.2</span> Random split
into two groups</h5>
<p>Following is an even stronger simplification of the real age with an
arbitrary split at 30 years old. We choose this value <strong>based on
nothing</strong>. We will see later if simplifying the information based
on arbitrary values is a good strategy (you may already have an idea of
how well it will work…).</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df[,<span class="at">AgeCat:=</span> <span class="fu">as.factor</span>(<span class="fu">ifelse</span>(Age <span class="sc">&gt;</span> <span class="dv">30</span>, <span class="st">&quot;Old&quot;</span>, <span class="st">&quot;Young&quot;</span>))])</span></code></pre></div>
<pre><code>##    ID Treatment  Sex Age Improved AgeDiscret AgeCat
## 1: 57   Treated Male  27     Some          3  Young
## 2: 46   Treated Male  29     None          3  Young
## 3: 77   Treated Male  30     None          3  Young
## 4: 17   Treated Male  32   Marked          3    Old
## 5: 36   Treated Male  46   Marked          5    Old
## 6: 23   Treated Male  58   Marked          6    Old</code></pre>
</div>
<div id="risks-in-adding-correlated-features" class="section level5" number="1.2.2.2.3">
<h5><span class="header-section-number">1.2.2.2.3</span> Risks in adding
correlated features</h5>
<p>These new features are highly correlated to the <code>Age</code>
feature because they are simple transformations of this feature.</p>
<p>For many machine learning algorithms, using correlated features is
not a good idea. It may sometimes make prediction less accurate, and
most of the time make interpretation of the model almost impossible.
GLM, for instance, assumes that the features are uncorrelated.</p>
<p>Fortunately, decision tree algorithms (including boosted trees) are
very robust to these features. Therefore we have nothing to do to manage
this situation.</p>
</div>
<div id="cleaning-data" class="section level5" number="1.2.2.2.4">
<h5><span class="header-section-number">1.2.2.2.4</span> Cleaning
data</h5>
<p>We remove ID as there is nothing to learn from this feature (it would
just add some noise).</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>df[,ID<span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]</span></code></pre></div>
<p>We will list the different values for the column
<code>Treatment</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">levels</span>(df[,Treatment])</span></code></pre></div>
<pre><code>## [1] &quot;Placebo&quot; &quot;Treated&quot;</code></pre>
</div>
</div>
<div id="encoding-categorical-features" class="section level4" number="1.2.2.3">
<h4><span class="header-section-number">1.2.2.3</span> Encoding
categorical features</h4>
<p>Next step, we will transform the categorical data to dummy variables.
Several encoding methods exist, e.g., <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a> is a
common approach. We will use the <a href="https://stats.oarc.ucla.edu/r/library/r-library-contrast-coding-systems-for-categorical-variables/">dummy
contrast coding</a> which is popular because it produces “full rank”
encoding (also see <a href="http://appliedpredictivemodeling.com/blog/2013/10/23/the-basics-of-encoding-categorical-data-for-predictive-models">this
blog post by Max Kuhn</a>).</p>
<p>The purpose is to transform each value of each <em>categorical</em>
feature into a <em>binary</em> feature <code>{0, 1}</code>.</p>
<p>For example, the column <code>Treatment</code> will be replaced by
two columns, <code>TreatmentPlacebo</code>, and
<code>TreatmentTreated</code>. Each of them will be <em>binary</em>.
Therefore, an observation which has the value <code>Placebo</code> in
column <code>Treatment</code> before the transformation will have after
the transformation the value <code>1</code> in the new column
<code>TreatmentPlacebo</code> and the value <code>0</code> in the new
column <code>TreatmentTreated</code>. The column
<code>TreatmentPlacebo</code> will disappear during the contrast
encoding, as it would be absorbed into a common constant intercept
column.</p>
<p>Column <code>Improved</code> is excluded because it will be our
<code>label</code> column, the one we want to predict.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>sparse_matrix <span class="ot">&lt;-</span> <span class="fu">sparse.model.matrix</span>(Improved <span class="sc">~</span> ., <span class="at">data =</span> df)[,<span class="sc">-</span><span class="dv">1</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(sparse_matrix)</span></code></pre></div>
<pre><code>## 6 x 9 sparse Matrix of class &quot;dgCMatrix&quot;
##   TreatmentTreated SexMale Age AgeDiscret3 AgeDiscret4 AgeDiscret5 AgeDiscret6
## 1                1       1  27           1           .           .           .
## 2                1       1  29           1           .           .           .
## 3                1       1  30           1           .           .           .
## 4                1       1  32           1           .           .           .
## 5                1       1  46           .           .           1           .
## 6                1       1  58           .           .           .           1
##   AgeDiscret7 AgeCatYoung
## 1           .           1
## 2           .           1
## 3           .           1
## 4           .           .
## 5           .           .
## 6           .           .</code></pre>
<blockquote>
<p>Formula <code>Improved ~ .</code> used above means transform all
<em>categorical</em> features but column <code>Improved</code> to binary
values. The <code>-1</code> column selection removes the intercept
column which is full of <code>1</code> (this column is generated by the
conversion). For more information, you can type
<code>?sparse.model.matrix</code> in the console.</p>
</blockquote>
<p>Create the output <code>numeric</code> vector (not as a sparse
<code>Matrix</code>):</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>output_vector <span class="ot">=</span> df[,Improved] <span class="sc">==</span> <span class="st">&quot;Marked&quot;</span></span></code></pre></div>
<ol style="list-style-type: decimal">
<li>set <code>Y</code> vector to <code>0</code>;</li>
<li>set <code>Y</code> to <code>1</code> for rows where
<code>Improved == Marked</code> is <code>TRUE</code> ;</li>
<li>return <code>Y</code> vector.</li>
</ol>
</div>
</div>
</div>
<div id="build-the-model" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Build the model</h2>
<p>The code below is very usual. For more information, you can look at
the documentation of <code>xgboost</code> function (or at the vignette
<a href="https://github.com/dmlc/xgboost/blob/master/R-package/vignettes/xgboostPresentation.Rmd">XGBoost
presentation</a>).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>bst <span class="ot">&lt;-</span> <span class="fu">xgboost</span>(<span class="at">data =</span> sparse_matrix, <span class="at">label =</span> output_vector, <span class="at">max_depth =</span> <span class="dv">4</span>,</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>               <span class="at">eta =</span> <span class="dv">1</span>, <span class="at">nthread =</span> <span class="dv">2</span>, <span class="at">nrounds =</span> <span class="dv">10</span>,<span class="at">objective =</span> <span class="st">&quot;binary:logistic&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  train-logloss:0.485466 
## [2]  train-logloss:0.438534 
## [3]  train-logloss:0.412250 
## [4]  train-logloss:0.395828 
## [5]  train-logloss:0.384264 
## [6]  train-logloss:0.374028 
## [7]  train-logloss:0.365005 
## [8]  train-logloss:0.351233 
## [9]  train-logloss:0.341678 
## [10] train-logloss:0.334465</code></pre>
<p>You can see some <code>train-error: 0.XXXXX</code> lines followed by
a number. It decreases. Each line shows how well the model explains your
data. Lower is better.</p>
<p>A small value for training error may be a symptom of <a href="https://en.wikipedia.org/wiki/Overfitting">overfitting</a>,
meaning the model will not accurately predict the future values.</p>
<blockquote>
<p>Here you can see the numbers decrease until line 7 and then
increase.</p>
<p>It probably means we are overfitting. To fix that I should reduce the
number of rounds to <code>nrounds = 4</code>. I will let things like
that because I don’t really care for the purpose of this example :-)</p>
</blockquote>
</div>
<div id="feature-importance" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Feature
importance</h2>
</div>
<div id="measure-feature-importance" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> Measure feature
importance</h2>
<div id="build-the-feature-importance-data.table" class="section level3" number="1.5.1">
<h3><span class="header-section-number">1.5.1</span> Build the feature
importance data.table</h3>
<p>Remember, each binary column corresponds to a single value of one of
<em>categorical</em> features.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>importance <span class="ot">&lt;-</span> <span class="fu">xgb.importance</span>(<span class="at">feature_names =</span> <span class="fu">colnames</span>(sparse_matrix), <span class="at">model =</span> bst)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(importance)</span></code></pre></div>
<pre><code>##             Feature        Gain      Cover  Frequency
## 1:              Age 0.622031769 0.67251696 0.67241379
## 2: TreatmentTreated 0.285750540 0.11916651 0.10344828
## 3:          SexMale 0.048744022 0.04522028 0.08620690
## 4:      AgeDiscret6 0.016604639 0.04784639 0.05172414
## 5:      AgeDiscret3 0.016373781 0.08028951 0.05172414
## 6:      AgeDiscret4 0.009270557 0.02858801 0.01724138</code></pre>
<blockquote>
<p>The column <code>Gain</code> provide the information we are looking
for.</p>
<p>As you can see, features are classified by <code>Gain</code>.</p>
</blockquote>
<p><code>Gain</code> is the improvement in accuracy brought by a feature
to the branches it is on. The idea is that before adding a new split on
a feature X to the branch there was some wrongly classified elements,
after adding the split on this feature, there are two new branches, and
each of these branch is more accurate (one branch saying if your
observation is on this branch then it should be classified as
<code>1</code>, and the other branch saying the exact opposite).</p>
<p><code>Cover</code> measures the relative quantity of observations
concerned by a feature.</p>
<p><code>Frequency</code> is a simpler way to measure the
<code>Gain</code>. It just counts the number of times a feature is used
in all generated trees. You should not use it (unless you know why you
want to use it).</p>
<div id="improvement-in-the-interpretability-of-feature-importance-data.table" class="section level4" number="1.5.1.1">
<h4><span class="header-section-number">1.5.1.1</span> Improvement in
the interpretability of feature importance data.table</h4>
<p>We can go deeper in the analysis of the model. In the
<code>data.table</code> above, we have discovered which features counts
to predict if the illness will go or not. But we don’t yet know the role
of these features. For instance, one of the question we may want to
answer would be: does receiving a placebo treatment helps to recover
from the illness?</p>
<p>One simple solution is to count the co-occurrences of a feature and a
class of the classification.</p>
<p>For that purpose we will execute the same function as above but using
two more parameters, <code>data</code> and <code>label</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>importanceRaw <span class="ot">&lt;-</span> <span class="fu">xgb.importance</span>(<span class="at">feature_names =</span> <span class="fu">colnames</span>(sparse_matrix), <span class="at">model =</span> bst, <span class="at">data =</span> sparse_matrix, <span class="at">label =</span> output_vector)</span></code></pre></div>
<pre><code>## Warning in xgb.importance(feature_names = colnames(sparse_matrix), model = bst,
## : xgb.importance: parameters &#39;data&#39;, &#39;label&#39; and &#39;target&#39; are deprecated</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cleaning for better display</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>importanceClean <span class="ot">&lt;-</span> importanceRaw[,<span class="st">`</span><span class="at">:=</span><span class="st">`</span>(<span class="at">Cover=</span><span class="cn">NULL</span>, <span class="at">Frequency=</span><span class="cn">NULL</span>)]</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(importanceClean)</span></code></pre></div>
<pre><code>##             Feature        Gain
## 1:              Age 0.622031769
## 2: TreatmentTreated 0.285750540
## 3:          SexMale 0.048744022
## 4:      AgeDiscret6 0.016604639
## 5:      AgeDiscret3 0.016373781
## 6:      AgeDiscret4 0.009270557</code></pre>
<blockquote>
<p>In the table above we have removed two not needed columns and select
only the first lines.</p>
</blockquote>
<p>First thing you notice is the new column <code>Split</code>. It is
the split applied to the feature on a branch of one of the tree. Each
split is present, therefore a feature can appear several times in this
table. Here we can see the feature <code>Age</code> is used several
times with different splits.</p>
<p>How the split is applied to count the co-occurrences? It is always
<code>&lt;</code>. For instance, in the second line, we measure the
number of persons under 61.5 years with the illness gone after the
treatment.</p>
<p>The two other new columns are <code>RealCover</code> and
<code>RealCover %</code>. In the first column it measures the number of
observations in the dataset where the split is respected and the label
marked as <code>1</code>. The second column is the percentage of the
whole population that <code>RealCover</code> represents.</p>
<p>Therefore, according to our findings, getting a placebo doesn’t seem
to help but being younger than 61 years may help (seems logic).</p>
<blockquote>
<p>You may wonder how to interpret the <code>&lt; 1.00001</code> on the
first line. Basically, in a sparse <code>Matrix</code>, there is no
<code>0</code>, therefore, looking for one hot-encoded categorical
observations validating the rule <code>&lt; 1.00001</code> is like just
looking for <code>1</code> for this feature.</p>
</blockquote>
</div>
</div>
<div id="plotting-the-feature-importance" class="section level3" number="1.5.2">
<h3><span class="header-section-number">1.5.2</span> Plotting the
feature importance</h3>
<p>All these things are nice, but it would be even better to plot the
results.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">xgb.plot.importance</span>(<span class="at">importance_matrix =</span> importance)</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAwAAAAHgCAMAAAAlhPoXAAAC7lBMVEUAAAABAQECAgIDAwMEBAQFBQUGBgYHBwcICAgJCQkKCgoLCwsMDAwNDQ0ODg4PDw8QEBARERESEhITExMUFBQVFRUWFhYXFxcYGBgZGRkaGhobGxscHBwdHR0eHh4fHx8gICAhISEiIiIjIyMkJCQlJSUmJiYnJycoKCgpKSkqKiorKyssLCwtLS0uLi4vLy8wMDAyMjIzMzM0NDQ1NTU2NjY3Nzc4ODg5OTk6Ojo7Ozs8PDw9PT0+Pj4/Pz9AQEBBQUFCQkJDQ0NERERFRUVGRkZHR0dISEhJSUlKSkpLS0tMTExNTU1OTk5PT09QUFBRUVFSUlJTU1NUVFRVVVVWVlZXV1dYWFhZWVlaWlpbW1tcXFxdXV1eXl5fX19gYGBhYWFiYmJjY2NkZGRlZWVmZmZnZ2dpaWlqampra2tsbGxtbW1ubm5vb29wcHBxcXFycnJzc3N0dHR1dXV2dnZ3d3d4eHh5eXl6enp7e3t8fHx9fX1+fn5/f3+AgICBgYGCgoKDg4OEhISFhYWGhoaHh4eIiIiJiYmKioqLi4uMjIyNjY2Ojo6Pj4+QkJCRkZGSkpKTk5OUlJSVlZWWlpaXl5eYmJiZmZmampqbm5ucnJydnZ2enp6fn5+goKChoaGioqKjo6OkpKSlpaWmpqanp6eoqKipqamqqqqrq6usrKyurq6vr6+wsLCxsbGysrKzs7O0tLS1tbW2tra3t7e4uLi5ubm6urq7u7u8vLy9vb2+vr6/v7/AwMDBwcHCwsLDw8PFxcXGxsbHx8fIyMjJycnKysrLy8vMzMzNzc3Ozs7Pz8/R0dHS0tLT09PU1NTV1dXX19fY2NjZ2dna2trb29vc3Nzd3d3e3t7f39/g4ODh4eHi4uLj4+Pk5OTl5eXm5ubn5+fo6Ojp6enq6urr6+vs7Ozt7e3u7u7v7+/w8PDx8fHy8vLz8/P09PT19fX29vb39/f4+Pj5+fn6+vr7+/v8/Pz9/f3+/v7////2es7SAAAACXBIWXMAAA7DAAAOwwHHb6hkAAASiUlEQVR4nO3deZwU5Z3H8WJABubgGlgOjRwGTDg1yK6bsLIxYrISvDCLV6JxhXVdREdJzIhKJBE1ispljByCuuzCIpAgrEFcD8gqwhqios5gZwQUFwUdmBng+W+rh24zzUwxRc3TU131/bxfL6rp7urfa6iuD91zwOMYQJgT9gcAhIkAII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AII0AIC0eAbwAZPJ76hAAYsnvqUMAiCW/pw4BIJb8njoEgFjye+oQAGLJ76lDAIglv6cOASCW/J46BIBY8nvqEABiye+pQwCIJb+nDgEglvyeOgSAWPJ76uRuAJOcTb73DftoI+f4PXVyNoCqztdd7nvnsI82co7fUydnA1hwVkV+pXu5bnDHMePLzJvndur/G8+dwz7ayDl+z7OcDWDEE2ZMmTGJgoW1S1uVfdbjnpqtJ//Wa+ewjzZyjt/zLFcD2NLpC7O26wEzc4R75dyyp051L6aP9do77KONnOP3RMvVACa0KSkpceab0nHulevKftGmY8eORWd67R320UbO8Xui5WgA+4pWJxKJnw41DydfAUaXLRriXuz+0Gv3sI82co7fMy1HA5jbL7ndkbdhV+Hi6uV5ZZ90nVnz52FTvHYP+2gj5/g903I0gGFT6y5GX2h+N6DoonOmmS1/37n7pGqv3cM+2sg5fs+0HA3gS5VvuJtvz2lir7CPNnKO3xMs1wP4Y+Hmw2vav93EXmEfbeQcvydYrgdgHuvbfvCKpnYK+2gj5/g9v3I+AF/CPtrIOX5PHQJALPk9dQgAseT31CEAxJLfU4cAEEt+Tx0CQCz5PXUIALHk99QhAMSS31OHABBLfk+deAQABEQAkEYAkEYAkEYAkEYAkEYAkBaPAML+onMYwj7mMUEAURX2MY8JAoiqsI95TBBAVIV9zGOCAKIq7GMeEwQQVWEf85gggKgK+5jHBAFEVdjHPCYIIKrCPuYxQQBRFfYxjwkCiKqw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dfDHxiMAICACgDQCgDQCgDQCgDQCgDQCgDQCgDQCgDQCgDQCgDQCgLRIB7D49HbfWN/oFWtTjfl9O9tDa345oGDg3CN2h9b+vE/ByFebP/PYP37VV638qGn9qZ86SefbHWrWDm/X++eHT3hGlANY3urWVWPbvdnIFWtTjdncJb/5MzOH3lwwY+2UvF/ZHfqT9g+tGVvwjt2hrpsdGwFkTH3J+cWsWbNW2R36Qusfr5t+0vQTHhLlAAZeacyhIVc3csXa1NpH2lsJoP7QL066z91e28vq0KrCe4w52OkOq0NdrxR2tRFAxtTZxRZe/Y4dOmKcu7ntxF9WIhzAh85yd1vWreEVa1PNhqIZD1oIIGPozlvecrf3Oc39lwEZQ2s27na33UqbOfPY43jg9PsHWQggc+rEkabaQgLHPP8bgg2NcAAvOlvd7Xxnb4Mr1qaa3R+bmRYCaOSj+7sh1ofumZy/1fLQW4cfshFA5tSzzz4rr8OUZv/LoIyh65yNo1oVl0l9DrDKKXe3/+HsaHDF2tQkGwE0/OjmOCtsD33IccqaO/OYoZvabTU2AsiYeqS4w6zVN7S60erQp5xTJ6+a1OrEP7GKcAArnQp3u8xJNLhibWqSjQAaDF2QN9X60O2vP9C22W+BMoYe/PqdxkoAGVMPrfpfdzux9cc2hy50kkFd0/mEp0Q4gBed5BcAFjj7GlyxNjXJzlugzKG/bHWX/aGuKW2a++fPGHp7nx07d55+7c5DzRza2Ie62nnZ5tBlzloT6C/ACAdQ6ax0t3f0bHjF2tQkGwEcM/SmvNnNn5k5dNe85D83X+Jstzn0G85R5c0cmjl154Lk5+vLnbdsDt3irHa3S53KE50S4QDM16415vDQqxq5Ym2qsRNA5tDprZdZGJk59ANnpru9ukMz/n+EhkNffc7V+/vPVTV3aMbUHU7ynfr4U5r9WXD9oYd7XOlur+57wkOiHMCTTumaS9q5byjnX/D5X65YnWosBVB/6HttzpyZdNDmUPOjwofWTHQetfqR1t1g43OAzKlXFT78XxOdp+0OXeBM/v2trRaf8JAoB2Dm9Gk3PPmt8NLkl8LSV+xOtRRA/aGPpN5YNPsrthkf6YGpfdsOWdLskQ3++HYCyPxQy/rmD11qeah5alDbAQH+g6xIBwA0FwFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFAGgFA2v8Dxx/TzEb4CSQAAAAASUVORK5CYII=" style="display: block; margin: auto;" /></p>
<p>Feature have automatically been divided in 2 clusters: the
interesting features… and the others.</p>
<blockquote>
<p>Depending of the dataset and the learning parameters you may have
more than two clusters. Default value is to limit them to
<code>10</code>, but you can increase this limit. Look at the function
documentation for more information.</p>
</blockquote>
<p>According to the plot above, the most important features in this
dataset to predict if the treatment will work are :</p>
<ul>
<li>the Age ;</li>
<li>having received a placebo or not ;</li>
<li>the sex is third but already included in the not interesting
features group ;</li>
<li>then we see our generated features (AgeDiscret). We can see that
their contribution is very low.</li>
</ul>
</div>
<div id="do-these-results-make-sense" class="section level3" number="1.5.3">
<h3><span class="header-section-number">1.5.3</span> Do these results
make sense?</h3>
<p>Let’s check some <strong>Chi2</strong> between each of these features
and the label.</p>
<p>Higher <strong>Chi2</strong> means better correlation.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">chisq.test</span>(df<span class="sc">$</span>Age, output_vector)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(c2)</span></code></pre></div>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  df$Age and output_vector
## X-squared = 35.475, df = 35, p-value = 0.4458</code></pre>
<p>Pearson correlation between Age and illness disappearing is
<strong>35.48</strong>.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">chisq.test</span>(df<span class="sc">$</span>AgeDiscret, output_vector)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(c2)</span></code></pre></div>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  df$AgeDiscret and output_vector
## X-squared = 8.2554, df = 5, p-value = 0.1427</code></pre>
<p>Our first simplification of Age gives a Pearson correlation is
<strong>8.26</strong>.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>c2 <span class="ot">&lt;-</span> <span class="fu">chisq.test</span>(df<span class="sc">$</span>AgeCat, output_vector)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(c2)</span></code></pre></div>
<pre><code>## 
##  Pearson&#39;s Chi-squared test with Yates&#39; continuity correction
## 
## data:  df$AgeCat and output_vector
## X-squared = 2.3571, df = 1, p-value = 0.1247</code></pre>
<p>The perfectly random split I did between young and old at 30 years
old have a low correlation of <strong>2.36</strong>. It’s a result we
may expect as may be in my mind &gt; 30 years is being old (I am 32 and
starting feeling old, this may explain that), but for the illness we are
studying, the age to be vulnerable is not the same.</p>
<p>Morality: don’t let your <em>gut</em> lower the quality of your
model.</p>
<p>In <em>data science</em> expression, there is the word
<em>science</em> :-)</p>
</div>
</div>
<div id="conclusion" class="section level2" number="1.6">
<h2><span class="header-section-number">1.6</span> Conclusion</h2>
<p>As you can see, in general <em>destroying information by simplifying
it won’t improve your model</em>. <strong>Chi2</strong> just
demonstrates that.</p>
<p>But in more complex cases, creating a new feature based on existing
one which makes link with the outcome more obvious may help the
algorithm and improve the model.</p>
<p>The case studied here is not enough complex to show that. Check <a href="http://www.kaggle.com/">Kaggle website</a> for some challenging
datasets. However it’s almost always worse when you add some arbitrary
rules.</p>
<p>Moreover, you can notice that even if we have added some not useful
new features highly correlated with other features, the boosting tree
algorithm have been able to choose the best one, which in this case is
the Age.</p>
<p>Linear model may not be that smart in this scenario.</p>
</div>
<div id="special-note-what-about-random-forests" class="section level2" number="1.7">
<h2><span class="header-section-number">1.7</span> Special Note: What
about Random Forests™?</h2>
<p>As you may know, <a href="https://en.wikipedia.org/wiki/Random_forest">Random Forests</a>
algorithm is cousin with boosting and both are part of the <a href="https://en.wikipedia.org/wiki/Ensemble_learning">ensemble
learning</a> family.</p>
<p>Both trains several decision trees for one dataset. The <em>main</em>
difference is that in Random Forests, trees are independent and in
boosting, the tree <code>N+1</code> focus its learning on the loss
(&lt;=&gt; what has not been well modeled by the tree
<code>N</code>).</p>
<p>This difference have an impact on a corner case in feature importance
analysis: the <em>correlated features</em>.</p>
<p>Imagine two features perfectly correlated, feature <code>A</code> and
feature <code>B</code>. For one specific tree, if the algorithm needs
one of them, it will choose randomly (true in both boosting and Random
Forests).</p>
<p>However, in Random Forests this random choice will be done for each
tree, because each tree is independent from the others. Therefore,
approximatively, depending of your parameters, 50% of the trees will
choose feature <code>A</code> and the other 50% will choose feature
<code>B</code>. So the <em>importance</em> of the information contained
in <code>A</code> and <code>B</code> (which is the same, because they
are perfectly correlated) is diluted in <code>A</code> and
<code>B</code>. So you won’t easily know this information is important
to predict what you want to predict! It is even worse when you have 10
correlated features…</p>
<p>In boosting, when a specific link between feature and outcome have
been learned by the algorithm, it will try to not refocus on it (in
theory it is what happens, reality is not always that simple).
Therefore, all the importance will be on feature <code>A</code> or on
feature <code>B</code> (but not both). You will know that one feature
have an important role in the link between the observations and the
label. It is still up to you to search for the correlated features to
the one detected as important if you need to know all of them.</p>
<p>If you want to try Random Forests algorithm, you can tweak XGBoost
parameters!</p>
<p>For instance, to compute a model with 1000 trees, with a 0.5 factor
on sampling rows and columns:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(agaricus.train, <span class="at">package=</span><span class="st">&#39;xgboost&#39;</span>)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span>(agaricus.test, <span class="at">package=</span><span class="st">&#39;xgboost&#39;</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>train <span class="ot">&lt;-</span> agaricus.train</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>test <span class="ot">&lt;-</span> agaricus.test</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="co">#Random Forest - 1000 trees</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>bst <span class="ot">&lt;-</span> <span class="fu">xgboost</span>(<span class="at">data =</span> train<span class="sc">$</span>data, <span class="at">label =</span> train<span class="sc">$</span>label, <span class="at">max_depth =</span> <span class="dv">4</span>, <span class="at">num_parallel_tree =</span> <span class="dv">1000</span>, <span class="at">subsample =</span> <span class="fl">0.5</span>, <span class="at">colsample_bytree =</span><span class="fl">0.5</span>, <span class="at">nrounds =</span> <span class="dv">1</span>, <span class="at">objective =</span> <span class="st">&quot;binary:logistic&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  train-logloss:0.456035</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co">#Boosting - 3 rounds</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>bst <span class="ot">&lt;-</span> <span class="fu">xgboost</span>(<span class="at">data =</span> train<span class="sc">$</span>data, <span class="at">label =</span> train<span class="sc">$</span>label, <span class="at">max_depth =</span> <span class="dv">4</span>, <span class="at">nrounds =</span> <span class="dv">3</span>, <span class="at">objective =</span> <span class="st">&quot;binary:logistic&quot;</span>)</span></code></pre></div>
<pre><code>## [1]  train-logloss:0.444882 
## [2]  train-logloss:0.302428 
## [3]  train-logloss:0.212847</code></pre>
<blockquote>
<p>Note that the parameter <code>round</code> is set to
<code>1</code>.</p>
</blockquote>
<blockquote>
<p><a href="https://www.stat.berkeley.edu/~breiman/RandomForests/cc_papers.htm"><strong>Random
Forests</strong></a> is a trademark of Leo Breiman and Adele Cutler and
is licensed exclusively to Salford Systems for the commercial release of
the software.</p>
</blockquote>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
