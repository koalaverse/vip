[{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Variable Importance Plots—An Introduction to the vip Package","text":"often machine learning (ML) models summarized using single metric (e.g., cross-validated accuracy) put production. Although often care predictions models, becoming routine (good practice) also better understand predictions! Understanding ML model makes predictions helps build trust model fundamental idea emerging field interpretable machine learning (IML).1 -depth discussion IML, see Molnar (2019b). paper, focus global methods quantifying importance2 features ML model; , methods help us understand global contribution feature model’s predictions. Computing variable importance (VI) communicating variable importance plots (VIPs) fundamental component IML main topic paper. many procedures discussed paper apply model makes predictions, noted methods heavily depend accuracy importance fitted model; hence, unimportant features may appear relatively important (albeit predictive) comparison included features. reason, stress usefulness understanding scale VI scores calculated take account assessing importance feature communicating results others. Also, point work focuses mostly post-hoc interpretability trained model given goal understand features driving model’s predictions. Consequently, work focuses functional understanding model contrast lower-level mechanistic understanding (Montavon, Samek, Müller 2018). , seek explain relationship model’s prediction behavior features without explaining full internal representation model.3 VI scores VIPs can constructed general ML models using number available packages. iml package (Molnar 2019a) provides FeatureImp() function computes feature importance general prediction models using permutation approach (discussed later). written R6 (Chang 2019) allows user specify generic loss function select one pre-defined list (e.g., mean squared error). also allows user specify whether importance measured difference ratio original model error model error permutation. user can also specify number repetitions used permuting feature help stabilize variability procedure. function can also run parallel using parallel backend supported foreach package (Revolution Analytics Weston, n.d.). ingredients package (Biecek, Baniecki, Izdebski 2019) also provides permutation-based VI scores feature_importance() function. (Note function recently replaced now deprecated DALEX function variable_importance() (Biecek 2019).) Similar iml::FeatureImp(), function allows user specify loss function importance scores computed (e.g., using difference ratio). also provides option sample training data shuffling data compute importance (default use n_sample = 1000), can help speed computation. mmpf package (Jones 2018) also provides permutation-based VI scores via mmpf::permutationImportance() function. Similar iml ingredients implementation, function flexible enough applied class ML models R. varImp package (Probst 2019) extends permutation-based method RFs package party (Hothorn et al. 2019) arbitrary measures measures package (Probst 2018). Additionally, functions varImp include option using conditional approach described Strobl et al. (2008) reliable presence correlated features. number RF-specific VI packages exist CRAN, including, limited , vita (Celik 2015), rfVarImpOOB (Loecher 2019), randomForestExplainer (Paluszynska, Biecek, Jiang 2019), tree.interpreter (Sun 2019).4. caret package (Kuhn 2020) includes general varImp() function computing model-specific filter-based VI scores. Filter-based approaches, described Kuhn Johnson (2013), make use fitted model measure VI. also take account predictors model. regression problems, popular filter-based approach measuring VI numeric predictor \\(x\\) first fit flexible nonparametric model \\(x\\) target \\(Y\\); example, locally-weighted polynomial regression (LOWESS) method developed Cleveland (1979). fit, pseudo-\\(R^2\\) measure can obtained resulting residuals used measure VI. categorical predictors, different method based standard statistical tests (e.g., \\(t\\)-tests ANOVAs) can employed; see Kuhn Johnson (2013) details. classification problems, area ROC curve (AUC) statistic can used quantify predictor importance. AUC statistic computed using predictor \\(x\\) input ROC curve. \\(x\\) can reasonably separate classes \\(Y\\), clear indicator \\(x\\) important predictor (terms class separation) captured corresponding AUC statistic. problems two classes, extensions ROC curve one-vs-approach can used. use mlr interface fitting ML models (Bischl et al. 2020), can use getFeatureImportance() function extract model-specific VI scores various tree-based models (e.g., RFs GBMs). Unlike caret, model needs fit via mlr interface; instance, use getFeatureImportance() ranger (Wright, Wager, Probst 2020) model unless fit using mlr. iml DALEX packages provide model-agnostic approaches computing VI, caret, extent, mlr, provide model-specific approaches (e.g., using absolute value \\(t\\)-statistic linear models) well less accurate filter-based approaches. Furthermore, package completely different interface (e.g., iml written R6). vip package (B. Greenwell, Boehmke, Gray 2019) strives provide consistent interface model-specific model-agnostic approaches feature importance simple use. three important functions exported vip described : vi() computes VI scores using model-specific model-agnostic approaches (results always returned tibble [Müller Wickham (2019)}); vip() constructs VIPs using model-specific model-agnostic approaches ggplot2-style graphics (Wickham et al. 2019); Note vi() actually wrapper around four workhorse functions, {vi_model(), vi_firm(), vi_permute(), vi_shap(), compute various types VI scores. first computes model-specific VI scores, latter three produce model-agnostic ones. workhorse function actually gets called controlled method argument vi(); default method = \"model\" corresponds model-specific VI (see ?vip::vi details links documentation).","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"constructing-vips-in-r","dir":"Articles","previous_headings":"Introduction","what":"Constructing VIPs in R","title":"Variable Importance Plots—An Introduction to the vip Package","text":"’ll illustrate major concepts using Friedman 1 benchmark problem described Friedman (1991) Breiman (1996): \\[\\begin{equation}   Y_i = 10 \\sin\\left(\\pi X_{1i} X_{2i}\\right) + 20 \\left(X_{3i} - 0.5\\right) ^ 2 + 10 X_{4i} + 5 X_{5i} + \\epsilon_i, \\quad = 1, 2, \\dots, n, \\tag{1} \\end{equation}\\] \\(\\epsilon_i \\stackrel{iid}{\\sim} N\\left(0, \\sigma^2\\right)\\). Data model can generated using vip::gen_friedman(). default, features consist 10 independent variables uniformly distributed interval \\(\\left[0,1\\right]\\); however, 5 10 actually used true model. code chunk simulates 500 observations model Equation (1) \\(\\sigma = 1\\); see ?vip::gen_friedman details. Equation (1), clear features \\(X_1\\)–\\(X_5\\) important! (others don’t influence \\(Y\\) .) Also, based form model, ’d expect \\(X_4\\) important feature, probably followed \\(X_1\\) \\(X_2\\) (comparably important), \\(X_5\\) probably less important. influence \\(X_3\\) harder determine due quadratic nature, seems likely nonlinearity suppress variable’s influence observed range (.e., 0–1).","code":"trn <- vip::gen_friedman(500, sigma = 1, seed = 101)  # simulate training data tibble::as_tibble(trn)  # inspect output ## # A tibble: 500 × 11 ##        y     x1    x2    x3    x4     x5      x6    x7    x8    x9   x10 ##    <dbl>  <dbl> <dbl> <dbl> <dbl>  <dbl>   <dbl> <dbl> <dbl> <dbl> <dbl> ##  1 14.9  0.372  0.406 0.102 0.322 0.693  0.758   0.518 0.530 0.878 0.763 ##  2 15.3  0.0438 0.602 0.602 0.999 0.776  0.533   0.509 0.487 0.118 0.176 ##  3 15.1  0.710  0.362 0.254 0.548 0.0180 0.765   0.715 0.844 0.334 0.118 ##  4 10.7  0.658  0.291 0.542 0.327 0.230  0.301   0.177 0.346 0.474 0.283 ##  5 17.6  0.250  0.794 0.383 0.947 0.462  0.00487 0.270 0.114 0.489 0.311 ##  6 18.3  0.300  0.701 0.992 0.386 0.666  0.198   0.924 0.775 0.736 0.974 ##  7 14.6  0.585  0.365 0.283 0.488 0.845  0.466   0.715 0.202 0.905 0.640 ##  8 17.0  0.333  0.552 0.858 0.509 0.697  0.388   0.260 0.355 0.517 0.165 ##  9  8.54 0.622  0.118 0.490 0.390 0.468  0.360   0.572 0.891 0.682 0.717 ## 10 15.0  0.546  0.150 0.476 0.706 0.829  0.373   0.192 0.873 0.456 0.694 ## # ℹ 490 more rows"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"model-specific-vi","dir":"Articles","previous_headings":"","what":"Model-specific VI","title":"Variable Importance Plots—An Introduction to the vip Package","text":"machine learning algorithms way quantifying importance feature, refer model-specific VI. describe subsections follow. One particular issue model-specific VI scores necessarily comparable across different types models. example, directly comparing impurity-based VI scores tree-based models absolute value \\(t\\)-statistic linear models.","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"decision-trees-and-tree-ensembles","dir":"Articles","previous_headings":"Model-specific VI","what":"Decision trees and tree ensembles","title":"Variable Importance Plots—An Introduction to the vip Package","text":"Decision trees probably offer natural model-specific approach quantifying importance feature. binary decision tree, node \\(t\\), single predictor used partition data two homogeneous groups. chosen predictor one maximizes measure improvement \\(^t\\). relative importance predictor \\(X\\) sum squared improvements internal nodes tree \\(X\\) chosen partitioning variable; see Breiman, Friedman, Charles J. Stone (1984) details. idea also extends ensembles decision trees, RFs GBMs. ensembles, improvement score predictor averaged across trees ensemble. Fortunately, due stabilizing effect averaging, improvement-based VI metric often reliable large ensembles; see Hastie, Tibshirani, Friedman (2009, 368). RFs offer additional method computing VI scores. idea use leftover --bag (OOB) data construct validation-set errors tree. , predictor randomly shuffled OOB data error computed . idea variable \\(X\\) important, validation error go \\(X\\) perturbed OOB data. difference two errors recorded OOB data averaged across trees forest. Note methods constructing VI scores can unreliable certain situations; example, predictor variables vary scale measurement number categories [Strobl et al. (2007), predictors highly correlated (Strobl et al. 2008). varImp package discussed earlier provides methods address concerns random forests package party, similar functionality also built partykit package (Hothorn Zeileis 2019). vip package also supports conditional importance described (Strobl et al. 2008) party- partykit-based RFs; see ?vip::vi_model details. Later , ’ll discuss general permutation method can applied supervised learning model. illustrate, fit CART-like regression tree, RF, GBM simulated training data. (Note: number different packages available fitting types models, just picked popular implementations illustration.) packages include ability compute VI scores features model; however, implementation rather package-specific, shown code chunk . results displayed Figure ?? (code reproduce plots omitted can made available upon request).  expect, three methods rank variables x1–x5 important others. good news, unfortunate remember different functions ways extracting plotting VI scores various model fitting functions. one place vip can help…one function rule ! vip loaded, can use vi() extract tibble VI scores.5 Notice vi() function always returns tibble6 two columns: Variable Importance (exceptions coefficient-based models also include Sign column giving sign corresponding coefficient, permutation importance involving multiple Monte Carlo simulations, later). Also, default, vi() always orders VI scores highest lowest; , among options, can controlled user (see ?vip::vi details). Plotting VI scores vip() just straightforward. example, following code can used reproduce Figure ??. Notice vip() function always returns \"ggplot\" object (default, bar plot). large models many features, Cleveland dot plot effective (fact, number useful plotting options can fiddled ). call vip() change useful options (resulting plot displayed Figure ??. Note can also call vip() directly \"vi\" object ’s already constructed.","code":"# Load required packages library(rpart)          # for fitting CART-like decision trees library(randomForest)   # for fitting RFs library(xgboost)        # for fitting GBMs  # Fit a single regression tree tree <- rpart(y ~ ., data = trn)  # Fit an RF set.seed(101)  # for reproducibility rfo <- randomForest(y ~ ., data = trn, importance = TRUE)  # Fit a GBM set.seed(102)  # for reproducibility bst <- xgboost(   data = data.matrix(subset(trn, select = -y)),   label = trn$y,   objective = \"reg:squarederror\",   nrounds = 100,   max_depth = 5,   eta = 0.3,   verbose = 0  # suppress printing ) # Extract VI scores from each model vi_tree <- tree$variable.importance vi_rfo <- rfo$variable.importance  # or use `randomForest::importance(rfo)` vi_bst <- xgb.importance(model = bst) # Load required packages library(vip)  # Compute model-specific VI scores vi(tree)  # CART-like decision tree ## # A tibble: 10 × 2 ##    Variable Importance ##    <chr>         <dbl> ##  1 x4            4234. ##  2 x2            2513. ##  3 x1            2461. ##  4 x5            1230. ##  5 x3             688. ##  6 x6             533. ##  7 x7             357. ##  8 x9             331. ##  9 x8             276. ## 10 x10            275. vi(rfo)   # RF ## # A tibble: 10 × 2 ##    Variable Importance ##    <chr>         <dbl> ##  1 x4           72.9   ##  2 x2           61.4   ##  3 x1           55.6   ##  4 x5           37.0   ##  5 x3           22.0   ##  6 x8            1.84  ##  7 x6            1.12  ##  8 x9            0.720 ##  9 x7           -1.39  ## 10 x10          -2.61 vi(bst)   # GBM ## # A tibble: 10 × 2 ##    Variable Importance ##    <chr>         <dbl> ##  1 x4          0.403   ##  2 x2          0.225   ##  3 x1          0.189   ##  4 x5          0.0894  ##  5 x3          0.0682  ##  6 x9          0.00802 ##  7 x6          0.00746 ##  8 x7          0.00400 ##  9 x10         0.00377 ## 10 x8          0.00262 library(patchwork)  # for easily arranging multiple ggplot2 plots  p1 <- vip(tree) + ggtitle(\"Single tree\") p2 <- vip(rfo) + ggtitle(\"Random forest\") p3 <- vip(bst) + ggtitle(\"Gradient boosting\")  # Display plots in a grid (Figure 1) p1 + p2 + p3 # Construct VIP (Figure 2) library(ggplot2)  # for theme_light() function vip(bst, num_features = 5, geom = \"point\", horizontal = FALSE,     aesthetics = list(color = \"red\", shape = 17, size = 5)) +   theme_light()"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"linear-models","dir":"Articles","previous_headings":"Model-specific VI","what":"Linear models","title":"Variable Importance Plots—An Introduction to the vip Package","text":"multiple linear regression, linear models (LMs), absolute value \\(t\\)-statistic (scaled variant estimated coefficients) commonly used measure VI.7. Motivation use assoicated \\(t\\)-statistic given Bring (1994). idea also extends generalized linear models (GLMs). code chunk , fit LM simulated Friedman data (trn) allowing main effects two-way interactions, use step() function perform backward elimination. resulting VIP displayed Figure ??. major limitation approach VI score assigned term model, rather individual feature! can solve problem using one model-agnostic approaches discussed later. Multivariate adaptive regression splines (MARS), introduced Friedman (1991), automatic regression technique can seen generalization LMs GLMs. MARS algorithm, contribution (VI score) predictor determined using generalized cross-validation (GCV) statistic (though, statistics can also used; see details). example using earth package (Milborrow 2019) given (results plotted Figure ??):  access VI scores directly earth, can use earth::evimp() function.","code":"# Fit a LM linmod <- lm(y ~ .^2, data = trn) backward <- step(linmod, direction = \"backward\", trace = 0)  # Extract VI scores (vi_backward <- vi(backward)) ## Error in vi(backward): class name too long in 'vi' # Plot VI scores; by default, `vip()` displays the top ten features pal <- palette.colors(2, palette = \"Okabe-Ito\")  # colorblind friendly palette vip(vi_backward, num_features = length(coef(backward)),  # Figure 3     geom = \"point\", horizontal = FALSE, mapping = aes(color = Sign)) +   scale_color_manual(values = unname(pal)) +   theme_light() +   theme(axis.text.x = element_text(angle = 45, hjust = 1)) ## Error in vip(vi_backward, num_features = length(coef(backward)), geom = \"point\", : object 'vi_backward' not found # Load required packages library(earth)  # Fit a MARS model mars <- earth(y ~ ., data = trn, degree = 2, pmethod = \"exhaustive\")  # Extract VI scores vi(mars, type = \"gcv\") ## # A tibble: 10 × 2 ##    Variable Importance ##    <chr>         <dbl> ##  1 x4            100   ##  2 x1             83.2 ##  3 x2             83.2 ##  4 x5             59.3 ##  5 x3             43.5 ##  6 x6              0   ##  7 x7              0   ##  8 x8              0   ##  9 x9              0   ## 10 x10             0 # Plot VI scores (Figure 4) vip(mars)"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"neural-networks","dir":"Articles","previous_headings":"Model-specific VI","what":"Neural networks","title":"Variable Importance Plots—An Introduction to the vip Package","text":"neural networks (NNs), two popular methods constructing VI scores Garson algorithm (Garson 1991), later modified Goh (1995), Olden algorithm (Olden, Joy, Death 2004). algorithms, basis VI scores network’s connection weights. Garson algorithm determines VI identifying weighted connections nodes interest. Olden’s algorithm, hand, uses products raw connection weights input output neuron sums products across hidden neurons. shown outperform Garson method various simulations. DNNs, similar method due Gedeon (1997) considers weights connecting input features first two hidden layers (simplicity speed); method can slow large networks. illustrate two methods using vip() nnet package (Ripley 2016) (see results Figure ??).","code":"# Load required packages library(nnet)  # Fit a neural network set.seed(0803)  # for reproducibility nn <- nnet(y ~ ., data = trn, size = 7, decay = 0.1,            linout = TRUE, trace = FALSE)  # Construct VIPs p1 <- vip(nn, type = \"garson\") p2 <- vip(nn, type = \"olden\")  # Display plots in a grid (Figure 5) p1 + p2"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"model-agnostic-vi","dir":"Articles","previous_headings":"","what":"Model-agnostic VI","title":"Variable Importance Plots—An Introduction to the vip Package","text":"Model-agnostic interpretability separates interpretation model. Compared model-specific approaches, model-agnostic VI methods flexible can applied supervised learning algorithm. section, discuss model-agnostic methods quantifying global feature importance using three different approaches: simple variance-based approach; permutation-based feature importance; Shapley-based feature importance.","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"variance-based-methods","dir":"Articles","previous_headings":"Model-agnostic VI","what":"Variance-based methods","title":"Variable Importance Plots—An Introduction to the vip Package","text":"first model-agnostic method based simple feature importance ranking measure (FIRM); details, see B. M. Greenwell, Boehmke, McCarthy (2018), Zien et al. (2009), Scholbeck et al. (2019). specific approach used based quantifying “flatness” effects feature.8 Feature effects can assessed using partial dependence plots (PDPs) individual conditional expectation (ICE) curves (Goldstein et al. 2015). PDPs ICE curves help visualize effect low cardinality subsets feature space estimated prediction surface (e.g., main effects two/three-way interaction effects.). also model-agnostic can constructed way supervised learning algorithm. , fit projection pursuit regression (PPR) model (see ?stats::ppr details references) construct PDPs feature using pdp package B. M. Greenwell (2017). results displayed Figure ??. Notice PDPs uninformative features relatively flat compared PDPs features x1–x5!  Next, compute PDP-based VI scores fitted PPR NN models. PDP method constructs VI scores quantify relative “flatness” PDP (default, defined computing standard deviation \\(y\\)-axis values PDP). use PDP method, specify method = \"firm\" call vi() vip() (just use vi_firm() directly):  Figure ?? display PDP-based feature importance previously obtained PPR NN models. VI scores essentially capture variability partial dependence values main effect. ICE curve method similar PDP method, except measure “flatness” individual ICE curve aggregate results (e.g., averaging). (substantial) interaction effects, using ICE curves produce results similar using PDPs (just averaged ICE curves). However, strong interaction effects present, can obfuscate main effects render PDP-based approach less useful (since PDPs important features can relatively flat certain interactions present; see Goldstein et al. (2015) details). fact, probably safest always use ICE curves employing FIRM method. , display ICE curves feature fitted PPR model using \\(y\\)-axis scale; see Figure ??. , clear difference ICE curves features x1–x5 x6–x10; later relatively flat comparison. Also, notice ICE curves within feature relatively parallel (ICE curves within feature perfectly parallel, standard deviation curve results identical PDP method). example, interaction term x1 x2 obfuscate PDPs main effects results much different.  Obtaining ICE-based feature importance scores also straightforward, just specify ice = TRUE using FIRM approach. illustrated code chunk results, displayed Figure ??, similar obtained using PDP method.  using method = \"firm\", feature effect values stored attribute called \"effects\". convenience feature effect plots (e.g., PDPs ICE curves) can easily reconstructed compared VI scores, demonstrated example (see Figure ??):","code":"# Fit a PPR model (nterms was chosen using the caret package with 5 repeats of # 5-fold cross-validation) pp <- ppr(y ~ ., data = trn, nterms = 11)  # Construct VIPs p1 <- vip(pp, method = \"firm\") + ggtitle(\"PPR\") p2 <- vip(nn, method = \"firm\") + ggtitle(\"NN\")  # Display plots in a grid (Figure 7) p1 + p2 # Construct VIPs p1 <- vip(pp, method = \"firm\", ice = TRUE) + ggtitle(\"PPR\") p2 <- vip(nn, method = \"firm\", ice = TRUE) + ggtitle(\"NN\")  # Display plots in a grid (Figure 9) p1 + p2 # Construct PDP-based VI scores (vis <- vi(pp, method = \"firm\")) ## # A tibble: 10 × 2 ##    Variable Importance ##    <chr>         <dbl> ##  1 x4           2.96   ##  2 x2           2.21   ##  3 x1           2.14   ##  4 x5           1.53   ##  5 x3           1.46   ##  6 x6           0.128  ##  7 x9           0.114  ##  8 x8           0.0621 ##  9 x10          0.0374 ## 10 x7           0.0170 # Reconstruct PDPs for all 10 features (Figure 10) par(mfrow = c(2, 5)) for (name in paste0(\"x\", 1:10)) {   plot(attr(vis, which = \"effects\")[[name]], type = \"l\", ylim = c(9, 19), las = 1) }"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"permutation-method","dir":"Articles","previous_headings":"Model-agnostic VI","what":"Permutation method","title":"Variable Importance Plots—An Introduction to the vip Package","text":"permutation method exists various forms made popular Breiman (2001) RFs, generalized extended Fisher, Rudin, Dominici (2018). permutation approach used vip quite simple outlined Algorithm 1 . idea randomly permute values important feature training data, training performance degrade (since permuting values feature effectively destroys relationship feature target variable). course assumes model properly tuned (e.g., using cross-validation) fitting. permutation approach uses difference baseline performance measure (e.g., training \\(R^2\\), AUC, RMSE) performance measure obtained permuting values particular feature training data (Note: model refit training data randomly permuting values feature). also important note method may appropriate , example, highly correlated features (since permuting one feature time may lead unlikely data instances). Let \\(x_1, x_2, \\dots, x_j\\) features interest let \\(M_{orig}\\) baseline performance metric trained model; brevity, ’ll assume smaller better (e.g., classification error RMSE). permutation-based importance scores can computed follows: \\(= 1, 2, \\dots, j\\): Permute values feature \\(x_i\\) training data. Recompute performance metric permuted data \\(M_{perm}\\). Record difference baseline using \\(VI\\left(x_i\\right) = M_{perm} - M_{orig}\\). Return VI scores \\(VI\\left(x_1\\right), VI\\left(x_2\\right), \\dots, VI\\left(x_j\\right)\\). Algorithm 1: simple algorithm constructing permutation-based VI scores. Algorithm 1 can improved modified number ways. instance, process can repeated several times results averaged together. helps provide stable VI scores, also opportunity measure variability. Rather taking difference step (c), Molnar (2019b, sec. 5.5.4) argues using ratio \\(M_{perm} / M_{orig}\\) makes importance scores comparable across different problems. ’s also possible assign importance scores groups features (e.g., permuting one feature time); useful features can categorized mutually exclusive groups, instance, categorical features *one-hot-encoded. use permutation approach vip, specify method = \"permute\" call vi() vip() (can use vi_permute() directly). Note using method = \"permute\" requires specifying additional arguments (e.g., training data, target name vector target values, prediction function, etc.); see ?vi_permute details. use vi_permute() first define prediction wrapper tells function generate write predictions chosen metric. example given previously fitted PPR NN models. use \\(R^2\\) (metric = \"rsq\") evaluation metric. results, displayed Figure ??, agree obtained using PDP- ICE-based methods.  permutation approach introduces randomness procedure therefore run computationally feasible. upside performing multiple runs Algorithm 1 allows us compute standard errors (among metrics) estimated VI scores, illustrated example ; specify nsim = 30 request feature permuted 30 times results averaged together. (Additionally, nsim > 1, can set call vip() construct boxplots raw permutation-based VI scores. useful want visualize variability VI estimates; see Figure ?? example.)  available performance metrics regression classification can listed using list_metrics() function, example: permutation method vip supports vector performance functions available yardstick (Kuhn, Vaughan, Hvitfeldt 2023). can also use custom metric (.e., loss function). Suppose example want measure importance using mean absolute error (MAE): \\[\\begin{equation}   MAE = \\frac{1}{n}\\sum_{= 1}^n\\left|y_i - \\hat{f}\\left(\\boldsymbol{x}_i\\right)\\right|, \\end{equation}\\] \\(\\hat{f}\\left(\\boldsymbol{x}_i\\right)\\) predicted value \\(y_i\\). simple function implementing metric given (consistent yardstick functions, user-supplied metric functions require two arguments: truth estimate). use computing permutation-based VI scores just pass via metric argument (warned, however, metric used computing permutation importance metric used train tune model). Also, since custom metric, need specify whether smaller value indicates better performance setting smaller_is_better = TRUE. results, displayed Figure ??, similar Figure ??, albeit different scale.  Although permutation importance naturally computed training data, may also useful shuffling measure performance new data! discussed depth Molnar (2019b, sec. 5.2). users interested computing permutation importance using new data, just supply train argument call vi(), vip(), vi_permute(). instance, suppose wanted use fraction original training data carry computations. case, simply pass sampled data train argument follows:  using permutation method nsim > 1, default keep permutation scores attribute called \"raw_scores\"; can turn behavior setting keep = FALSE call vi_permute(), vi(), vip(). keep = TRUE nsim > 1, can request permutation scores plotted setting all_permutations = TRUE call vip(), demonstrated code chunk (see Figure ??). also let’s visually inspect variability permutation scores within feature.","code":"# Prediction wrapper pfun_ppr <- function(object, newdata) {  # needs to return a numeric vector   stats::predict(object, newdata = newdata) } pfun_nnet <- function(object, newdata) {  # needs to return a numeric vector   stats::predict(object, newdata = newdata)[, 1L, drop = TRUE] }  # Plot VI scores set.seed(2021)  # for reproducibility p1 <- vip(pp, method = \"permute\", target = \"y\", metric = \"rsq\",           pred_wrapper = pfun_ppr) + ggtitle(\"PPR\") p2 <- vip(nn, method = \"permute\", target = \"y\", metric = \"rsq\",           pred_wrapper = pfun_nnet) + ggtitle(\"NN\")  # Display plots in a grid (Figure 11) p1 + p2 # Use 10 Monte Carlo reps set.seed(403)  # for reproducibility vis <- vi(pp, method = \"permute\", target = \"y\", metric = \"rsq\",           pred_wrapper = pfun_ppr, nsim = 30) vip(vis, geom = \"boxplot\")  # Figure 12 list_metrics() ##          metric                               description ## 1      accuracy                   Classification accuracy ## 2  bal_accuracy          Balanced classification accuracy ## 3        youden Youden;'s index (or Youden's J statistic) ## 4       roc_auc                      Area under ROC curve ## 5        pr_auc    Area under precision-recall (PR) curve ## 6       logloss                                  Log loss ## 7         brier                               Brier score ## 8           mae                       Mean absolute error ## 9          mape            Mean absolute percentage error ## 10         rmse                   Root mean squared error ## 11          rsq                   R-squared (correlation) ## 12     rsq_trad                   R-squared (traditional) ##                                task smaller_is_better yardstick_function ## 1  Binary/multiclass classification             FALSE       accuracy_vec ## 2  Binary/multiclass classification             FALSE   bal_accuracy_vec ## 3  Binary/multiclass classification             FALSE            j_index ## 4             Binary classification             FALSE        roc_auc_vec ## 5             Binary classification             FALSE         pr_auc_vec ## 6  Binary/multiclass classification              TRUE    mn_log_loss_vec ## 7  Binary/multiclass classification              TRUE    brier_class_vec ## 8                        Regression              TRUE            mae_vec ## 9                        Regression              TRUE           mape_vec ## 10                       Regression              TRUE           rmse_vec ## 11                       Regression             FALSE            rsq_vec ## 12                       Regression             FALSE       rsq_trad_vec mae <- function(truth, estimate) {   mean(abs(truth - estimate)) } # Construct VIP (Figure 13) set.seed(2321)  # for reproducibility p1 <- vip(nn, method = \"permute\", target = \"y\", metric = mae,     smaller_is_better = TRUE, pred_wrapper = pfun_nnet) +   ggtitle(\"Custom loss function: MAE\") set.seed(2321)  # for reproducibility p2 <- vip(nn, method = \"permute\", target = \"y\", metric = yardstick::mae_vec,     smaller_is_better = TRUE, pred_wrapper = pfun_nnet) +   ggtitle(\"Using `yardstick`'s MAE function\") p1 + p2 # Construct VIP (Figure 14) set.seed(2327)  # for reproducibility vip(nn, method = \"permute\", pred_wrapper = pfun_nnet, target = \"y\",     metric = \"rmse\",     train = trn[sample(nrow(trn), size = 400), ]) +  # sample 400 observations   ggtitle(\"Using a random subset of training data\") # Construct VIP (Figure 15) set.seed(8264)  # for reproducibility vip(nn, method = \"permute\", pred_wrapper = pfun_nnet, target = \"y\",     metric = \"mae\", nsim = 10, geom = \"point\",     all_permutations = TRUE, jitter = TRUE) +   ggtitle(\"Plotting all permutation scores\")"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"a-classification-example","dir":"Articles","previous_headings":"Model-agnostic VI > Permutation method","what":"A classification example","title":"Variable Importance Plots—An Introduction to the vip Package","text":"example, ’ll illustrate use permutation importance classification problem. start, ’ll use randomForest package (Liaw Wiener 2002) build (default) random forest predict survivability passengers ill-fated Titanic. source data (also available vip::titanic) contains 263 missing values (.e., NA’s) age column. titanic_mice version, ’ll use vignette, contains imputed values age column using multivariate imputation chained equations via mice package. Consequently, titanic_mice list containing 11 imputed versions original data; see ?vip::titanic_mice details. now, ’ll just use one 11 imputed versions: Next, ’ll build default random forest predict survivability: comparison, ’s plot OOB-based permutation importance scores available random forest (note setting include_type = TRUE results \\(x\\)-axis label including method importance computed):  categorical outcomes, random forests can provide predicted class labels (.e., classification) predicted class probabilities (.e., prediction), shown . performance metric choose permutation importance determine whether prediction wrapper return class label (factor) numeric vector class probabilities. ’ll start classification accuracy (metric used random forest’s build-OOB-based permutation VI scores). basic call vi() (, similarly, vi_permute()) look something like: Note standard deviation VI score also computed returned whenever nsim > 1. results comparable fitted random forest computed internally setting importance = TRUE nPerm = 30; difference random forest uses OOB data computing drop accuracy shuffling variable. Next, ’ll compute permutation VI scores using metric requires predicted probabilities. , ’ll use Brier score, measures accuracy individual probabilities (smaller better). However, instead using built-metric = \"brier\" option, ’ll pass corresponding yardstick function directly. Note modify prediction wrapper return predicted probabilities, single vector probabilities case binary outcome (case, care event survived = \"yes\"): Finally, illustrate use event_level argument, ’ll compute permutation-based VI scores using area ROC curve (AUROC metric = \"roc_auc\"). results negative? issue metrics like AUROC (similar area PR curve) treat one class outcomes “event” interest. case, using predicted probability event survived = \"yes\", default event level (yardstick therefore vip) always first class label alphabetical order (survived = \"\", case): Consequently, using metrics like AUROC, good idea set event_level parameter call vi() vi_permute(). fix previous issue, just set event level second class label using even_level = \"second\": Much better (just negative previous results, expected)! similar example using multiclass outcome, see discussion issue.","code":"head(t1 <- vip::titanic_mice[[1L]]) ##   survived pclass   age    sex sibsp parch ## 1      yes      1 29.00 female     0     0 ## 2      yes      1  0.92   male     1     2 ## 3       no      1  2.00 female     1     2 ## 4       no      1 30.00   male     1     2 ## 5       no      1 25.00 female     1     2 ## 6      yes      1 48.00   male     0     0 t1$pclass <- as.ordered(t1$pclass)  # makes more sense as an ordered factor library(randomForest)  set.seed(2053)  # for reproducibility (rfo <- randomForest(survived ~ ., data = t1, importance = TRUE, nPerm = 30)) ##  ## Call: ##  randomForest(formula = survived ~ ., data = t1, importance = TRUE,      nPerm = 30)  ##                Type of random forest: classification ##                      Number of trees: 500 ## No. of variables tried at each split: 2 ##  ##         OOB estimate of  error rate: 18.79% ## Confusion matrix: ##      no yes class.error ## no  727  82   0.1013597 ## yes 164 336   0.3280000 vip(rfo, include_type = TRUE) head(predict(rfo, newdata = t1, type = \"response\"))  # predicted class labels ##   1   2   3   4   5   6  ## yes yes yes  no yes  no  ## Levels: no yes head(predict(rfo, newdata = t1, type = \"prob\"))  # predicted class probabilities ##      no   yes ## 1 0.014 0.986 ## 2 0.114 0.886 ## 3 0.472 0.528 ## 4 0.716 0.284 ## 5 0.392 0.608 ## 6 0.894 0.106 pfun_class <- function(object, newdata) {  # prediction wrapper   predict(object, newdata = newdata, type = \"response\") }  # Compute mean decrease in accuracy set.seed(1359)  # for reproducibility vi(rfo,    method = \"permute\",    train = t1,    target = \"survived\",    metric = \"accuracy\",  # or pass in `yardstick::accuracy_vec` directly    # smaller_is_better = FALSE,  # no need to set for built-in metrics    pred_wrapper = pfun_class,    nsim = 30  # use 30 repetitions ) ## # A tibble: 5 × 3 ##   Variable Importance   StDev ##   <chr>         <dbl>   <dbl> ## 1 sex          0.226  0.0111  ## 2 pclass       0.0801 0.00488 ## 3 age          0.0738 0.00595 ## 4 sibsp        0.0346 0.00459 ## 5 parch        0.0166 0.00247 sort(rfo$importance[, \"MeanDecreaseAccuracy\"], decreasing = TRUE) ##        sex     pclass        age      parch      sibsp  ## 0.17102147 0.05877827 0.04408406 0.01895065 0.01583429 pfun_prob <- function(object, newdata) {  # prediction wrapper   predict(object, newdata = newdata, type = \"prob\")[, \"yes\"] }  # Compute mean increase in Brier score set.seed(1411)  # for reproducibility vi(rfo,    method = \"permute\",    train = t1,    target = \"survived\",    metric = yardstick::brier_class_vec,  # or pass in `\"brier\"` directly    smaller_is_better = FALSE,  # need to set when supplying a function    pred_wrapper = pfun_prob,    nsim = 30  # use 30 repetitions ) ## # A tibble: 5 × 3 ##   Variable Importance   StDev ##   <chr>         <dbl>   <dbl> ## 1 sex          0.209  0.00866 ## 2 pclass       0.0977 0.00479 ## 3 age          0.0947 0.00460 ## 4 parch        0.0542 0.00271 ## 5 sibsp        0.0414 0.00186 set.seed(1413)  # for reproducibility vi(rfo,    method = \"permute\",    train = t1,    target = \"survived\",    metric = \"roc_auc\",    pred_wrapper = pfun_prob,    nsim = 30  # use 30 repetitions ) ## # A tibble: 5 × 3 ##   Variable Importance   StDev ##   <chr>         <dbl>   <dbl> ## 1 parch       -0.0251 0.00351 ## 2 sibsp       -0.0283 0.00211 ## 3 age         -0.0850 0.00477 ## 4 pclass      -0.0920 0.00533 ## 5 sex         -0.229  0.0137 levels(titanic$survived) ## [1] \"no\"  \"yes\" set.seed(1413)  # for reproducibility vi(rfo,    method = \"permute\",    train = t1,    target = \"survived\",    metric = \"roc_auc\",    event_level = \"second\",  # use \"yes\" as class label/\"event\" of interest    pred_wrapper = pfun_prob,    nsim = 30  # use 30 repetitions ) ## # A tibble: 5 × 3 ##   Variable Importance   StDev ##   <chr>         <dbl>   <dbl> ## 1 sex          0.229  0.0137  ## 2 pclass       0.0920 0.00533 ## 3 age          0.0850 0.00477 ## 4 sibsp        0.0283 0.00211 ## 5 parch        0.0251 0.00351"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"benchmarks","dir":"Articles","previous_headings":"Model-agnostic VI > Permutation method","what":"Benchmarks","title":"Variable Importance Plots—An Introduction to the vip Package","text":"section, compare performance four implementations permutation-based VI scores: iml::FeatureImp() (version 0.11.1), ingredients::feature_importance() (version 2.3.0), mmpf::permutationImportance (version 0.0.5), vip::vi() (version 0.4.0). simulated 10,000 training observations Friedman 1 benchmark problem trained random forest using ranger package. implementation, computed permutation-based VI scores 100 times using microbenchmark package (Mersmann 2019). benchmark use parallel processing capability available iml vip implementations. results microbenchmark displayed Figure (fig:benchmark) summarized output . case, vip package (version 0.4.0) fastest, followed closely ingredients mmpf. noted, however, implementations vip iml can parallelized. best knowledge, case ingredients mmpf (although difficult write simple parallel wrapper either). code used generate benchmarks can found https://github.com/koalaverse/vip/blob/master/slowtests/slowtests-benchmarks.R.","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"shapley-method","dir":"Articles","previous_headings":"Model-agnostic VI","what":"Shapley method","title":"Variable Importance Plots—An Introduction to the vip Package","text":"Although vip focuses global VI methods, becoming increasing popular asses global importance aggregating local VI measures; particular, Shapley explanations (Štrumbelj Kononenko 2014). Using Shapley values (method coalitional game theory), prediction single instance \\(x^\\star\\) can explained assuming feature value \\(x^\\star\\) “player” game payout equal corresponding prediction \\(\\hat{f}\\left(x^\\star\\right)\\). Shapley values tell us fairly distribute “payout” (.e., prediction) among features. Shapley values become popular due attractive fairness properties posses (Lundberg Lee 2017). popular implementation available Python shap package (Lundberg Lee 2017); although number implementations now available R; example, iml, iBreakDown (Biecek et al. 2019), fastshap (B. Greenwell 2019). Obtaining global VI score Shapley values requires aggregating Shapley values feature across entire training set (least reasonable sample thereof). particular, use mean absolute value individual Shapley values feature. Unfortunately, Shapley values can computationally expensive, therefore approach may feasible large training sets (say, >3000 observations). fastshap package provides relief exploiting computational tricks, including option perform computations parallel (see details). Also, fast exact algorithms can exploited certain classes models. Starting vip version 0.4.0 can now use method = \"shap\" call vi() (use vi_shap() directly) compute global Shapley-based VI scores using method described (provided fastshap package installed)—see ?vip::vi_shap details. illustrate, compute Shapley-based VI scores xgboost model [R-xgboost] using Friedman data earlier; results displayed Figure (fig:vi-shap).9 ({Note: specifying include_type = TRUE call vip() causes type VI computed displayed part axis label.)  Passing exact = TRUE fastshap::explain() via ... argument call vip() (vi() vi_shap()) works lightgbm, xgboost, additive (generalized) linear models fit using R’s internal stats package. cases, prediction wrapper must supplied via ... argument. illustrate, let’s use previous random forest fit Titanic data set. Note Shapley explanation support classification, ’ll use probability-based prediction wrapper defined :","code":"# Load required packages library(xgboost)  # Feature matrix X <- data.matrix(subset(trn, select = -y))  # matrix of feature values  # Fit an XGBoost model; hyperparameters were tuned using 5-fold CV set.seed(859)  # for reproducibility bst <- xgboost(X, label = trn$y, nrounds = 338, max_depth = 3, eta = 0.1,                verbose = 0)  # Construct VIP (Figure 17) vip(bst, method = \"shap\", train = X, exact = TRUE, include_type = TRUE,     geom = \"point\", horizontal = FALSE,     aesthetics = list(color = \"forestgreen\", shape = 17, size = 5)) +   theme_light() pfun_prob <- function(object, newdata) {  # prediction wrapper   # For Shapley explanations, this should ALWAYS return a numeric vector   predict(object, newdata = newdata, type = \"prob\")[, \"yes\"] }  # Compute Shapley-based VI scores set.seed(853)  # for reproducibility vi_shap(rfo, train = subset(t1, select = -survived), pred_wrapper = pfun_prob,         nsim = 30) ## # A tibble: 5 × 2 ##   Variable Importance ##   <chr>         <dbl> ## 1 pclass       0.104  ## 2 age          0.0649 ## 3 sex          0.272  ## 4 sibsp        0.0260 ## 5 parch        0.0291"},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"drawbacks-of-existing-methods","dir":"Articles","previous_headings":"Model-agnostic VI","what":"Drawbacks of existing methods","title":"Variable Importance Plots—An Introduction to the vip Package","text":"discussed Hooker Mentch (2019), permute--predict methods—like PDPs, ICE curves, permutation importance—can produce results highly misleading.10 example, standard approach computing permutation-based VI scores involves independently permuting individual features. implicitly makes assumption observed features statistically independent. practice, however, features often independent can lead nonsensical VI scores. One way mitigate issue use conditional approach described Strobl et al. (2008); Hooker Mentch (2019) provides additional alternatives, permute--relearn importance. Unfortunately, best knowledge, approach yet available general purpose. similar modification can applied PDPs (Parr Wilson 2019)11 seems reasonable use FIRM approach strong dependencies among features present (though, given much thought consideration). already mentioned PDPs can misleading presence strong interaction effects. drawback, course, equally applies FIRM approach using PDPs computing VI scores. discussed earlier, can mitigated using ICE curves instead. Another alternative use accumulated local effect (ALE) plots (D. W. Apley Zhu 2016) (though haven’t really tested idea). Compared PDPs, ALE plots advantage faster compute less affected strong dependencies among features. downside, however, ALE plots complicated implement (hence, currently available using method = \"firm\"). ALE plots available ALEPlot (D. Apley 2018) iml packages. Hooker (2007) also argues feature importance (concern main effects) can misleading high dimensional settings, especially strong dependencies interaction effects among features, suggests approach based generalized functional ANOVA decomposition—though, knowledge, approach widely implemented open source.","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Variable Importance Plots—An Introduction to the vip Package","text":"VIPs help visualize strength relationship feature predicted response, accounting features model. ’ve discussed two types VI: model-specific model-agnostic, well strengths weaknesses. paper, showed construct VIPs various types “black box” models R using vip package. also briefly discussed related approaches available number R packages. Suggestions avoid high execution times discussed demonstrated via examples. paper based vip version 0.4.0. terms future development, vip can expanded number ways. example, plan incorporate option compute group-based conditional permutation scores. Although discussed paper, vip also includes promising statistic (similar variance-based VI scores previously discussed) measuring relative strength interaction features. Although VIPs can help understand features driving model’s predictions, ML practitioners cognizant fact none methods discussed paper uniformly best across situations; require accurate model properly tuned, checked consistency human domain knowledge.","code":""},{"path":"https://koalaverse.github.io/vip/articles/vip.html","id":"acknowledgments","dir":"Articles","previous_headings":"","what":"Acknowledgments","title":"Variable Importance Plots—An Introduction to the vip Package","text":"authors like thank anonymous reviewers Editor helpful comments suggestions. also like thank members 84.51\\(^{\\circ}\\) Interpretable Machine Learning Special Interest Group thoughtful discussions topics discussed herein.","code":""},{"path":[]},{"path":"https://koalaverse.github.io/vip/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Brandon M. Greenwell. Author, maintainer. Brad Boehmke. Author.","code":""},{"path":"https://koalaverse.github.io/vip/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Brandon M. Greenwell Bradley C. Boehmke (2020). Variable Importance Plots—Introduction vip Package. R Journal, 12(1), 343--366. URL https://doi.org/10.32614/RJ-2020-013.","code":"@Article{,   title = {Variable Importance Plots---An Introduction to the vip Package},   author = {Brandon M. Greenwell and Bradley C. Boehmke},   journal = {The R Journal},   year = {2020},   volume = {12},   number = {1},   pages = {343--366},   url = {https://doi.org/10.32614/RJ-2020-013}, }"},{"path":[]},{"path":"https://koalaverse.github.io/vip/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Variable Importance Plots","text":"vip R package constructing variable importance plots (VIPs). VIPs part larger framework referred interpretable machine learning (IML), includes (limited ): partial dependence plots (PDPs) individual conditional expectation (ICE) curves. PDPs ICE curves (available R package pdp) help visualize feature effects, VIPs help visualize feature impact (either locally globally). -progress, comprehensive, overview IML can found : https://github.com/christophM/interpretable-ml-book. Many supervised learning algorithms can naturally emit measure importance features used model, approaches embedded many different packages. downside, however, package uses different function interface can challenging (distracting) remember one (e.g., remembering use xgb.importance() xgboost models gbm.summary() gbm models). vip get one consistent interface computing variable importance many types supervised learning models across number packages. Additionally, vip offers number model-agnostic procedures computing feature importance (see next section) well experimental function quantifying strength potential interaction effects. details example usage, visit vip package website.","code":""},{"path":"https://koalaverse.github.io/vip/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Variable Importance Plots","text":"Model-based variable importance - Compute variable importance specific particular model (like random forest, gradient boosted decision trees, multivariate adaptive regression splines) wide range R packages (e.g., randomForest, ranger, xgboost, many ). Also supports caret parsnip (starting version 0.0.4) packages. Permutation-based variable importance - efficient implementation permutation feature importance algorithm discussed chapter Christoph Molnar’s Interpretable Machine Learning book. Shapley-based variable importance - efficient implementation feature importance based popular Shapley values via fastshap package. Variance-based variable importance - Compute variable importance using simple feature importance ranking measure (FIRM) approach. details, see see Greenwell et al. (2018) Scholbeck et al. (2019).","code":""},{"path":"https://koalaverse.github.io/vip/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Variable Importance Plots","text":"","code":"# The easiest way to get vip is to install it from CRAN: install.packages(\"vip\")  # Alternatively, you can install the development version from GitHub: if (!requireNamespace(\"remotes\")) {   install.packages(\"remotes\") } remotes::install_github(\"koalaverse/vip\")"},{"path":"https://koalaverse.github.io/vip/reference/bin.html","id":null,"dir":"Reference","previous_headings":"","what":"Bin a numeric vector — bin","title":"Bin a numeric vector — bin","text":"Function bin numeric vector","code":""},{"path":"https://koalaverse.github.io/vip/reference/bin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bin a numeric vector — bin","text":"","code":"bin(x, n_bins)"},{"path":"https://koalaverse.github.io/vip/reference/bin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bin a numeric vector — bin","text":"x numeric vector. Integer specifying number bins split x .","code":""},{"path":"https://koalaverse.github.io/vip/reference/gen_friedman.html","id":null,"dir":"Reference","previous_headings":"","what":"Friedman benchmark data — gen_friedman","title":"Friedman benchmark data — gen_friedman","text":"Simulate data Friedman 1 benchmark problem. data originally described Friedman (1991) Breiman (1996). details, see sklearn.datasets.make_friedman1.","code":""},{"path":"https://koalaverse.github.io/vip/reference/gen_friedman.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Friedman benchmark data — gen_friedman","text":"","code":"gen_friedman(   n_samples = 100,   n_features = 10,   n_bins = NULL,   sigma = 0.1,   seed = NULL )"},{"path":"https://koalaverse.github.io/vip/reference/gen_friedman.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Friedman benchmark data — gen_friedman","text":"n_samples Integer specifying number samples (.e., rows) generate. Default 100. n_features Integer specifying number features generate. Default 10. n_bins Integer specifying number (roughly) equal sized bins split response . Default NULL binning. Setting positive integer > 1 effectively turns classification problem n_bins gives number classes. sigma Numeric specifying standard deviation noise. seed Integer specifying random seed. NULL (default) results different time function run.","code":""},{"path":"https://koalaverse.github.io/vip/reference/gen_friedman.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Friedman benchmark data — gen_friedman","text":"Breiman, Leo (1996) Bagging predictors. Machine Learning 24, pages 123-140. Friedman, Jerome H. (1991) Multivariate adaptive regression splines. Annals Statistics 19 (1), pages 1-67.","code":""},{"path":"https://koalaverse.github.io/vip/reference/gen_friedman.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Friedman benchmark data — gen_friedman","text":"","code":"gen_friedman() #>             y           x1           x2         x3         x4          x5 #> 1   23.840987 0.6759721697 0.5125813521 0.07160379 0.99978627 0.271178257 #> 2    9.623661 0.9856958392 0.9642838873 0.03351095 0.24955093 0.250500011 #> 3   22.654672 0.4825402873 0.7847610181 0.13789961 0.69669849 0.761911532 #> 4   20.232250 0.4456876006 0.9189490753 0.30500337 0.54824237 0.847765672 #> 5    9.185394 0.0006588304 0.9077979270 0.79091867 0.65420285 0.172688548 #> 6    9.250396 0.9212993807 0.0260542023 0.64030548 0.36272326 0.896859805 #> 7   22.789935 0.5765405579 0.4894680525 0.19219761 0.88930341 0.850170494 #> 8   12.169586 0.6954413948 0.3028189589 0.13943872 0.13401661 0.425986421 #> 9   19.340471 0.6217532922 0.7752467443 0.23420838 0.36659762 0.806701331 #> 10   3.793405 0.8850848931 0.1239252316 0.59525327 0.02236348 0.021312950 #> 11  19.413926 0.4397395041 0.3611886650 0.39094931 0.97708755 0.904544010 #> 12   6.498691 0.2040736177 0.0627803814 0.68211590 0.31129201 0.417710888 #> 13  20.030404 0.8196485452 0.8272371439 0.51922226 0.72653047 0.839141774 #> 14  24.325077 0.5386889591 0.8067489006 0.77988461 0.89965647 0.802761870 #> 15   6.840599 0.0492286240 0.6635464525 0.59434994 0.26024182 0.630479756 #> 16   4.467399 0.3394161433 0.1120156294 0.44474067 0.31079865 0.023790262 #> 17  15.773778 0.6430535160 0.3247046669 0.91971075 0.16999976 0.899287550 #> 18  21.327641 0.9076674583 0.7251544110 0.14231176 0.71817093 0.560615089 #> 19  13.627077 0.5539126799 0.0861778562 0.37922109 0.71879158 0.930752811 #> 20   5.346005 0.0228288048 0.3503480782 0.58003563 0.32711820 0.346533943 #> 21  11.908613 0.0734738058 0.7593257639 0.85673325 0.64319400 0.238326720 #> 22  12.656367 0.8010455330 0.7365703774 0.48800525 0.23216312 0.115233585 #> 23   9.119648 0.5428822343 0.0767615237 0.16120203 0.28123957 0.558483608 #> 24  15.670994 0.5024930094 0.8700824017 0.21632527 0.18057260 0.481429608 #> 25   8.218650 0.0990956256 0.6461682799 0.79556184 0.41996217 0.061638433 #> 26   9.771555 0.8087382587 0.1461430411 0.84577016 0.38154611 0.005737968 #> 27  17.872139 0.0286039875 0.8538238918 0.99068950 0.93912513 0.585702214 #> 28  23.455408 0.8855307666 0.8788125345 0.94815567 0.80214038 0.996345679 #> 29  10.573043 0.6016014367 0.3496340397 0.27380223 0.10963093 0.441241066 #> 30   7.177664 0.2972732172 0.4656577776 0.75771528 0.05869202 0.206455562 #> 31  24.726120 0.5657286951 0.6616219610 0.99093952 0.80541971 0.549726494 #> 32  11.051004 0.7170329434 0.7876186040 0.30978760 0.01633929 0.061329732 #> 33   9.372561 0.4290181776 0.4004281636 0.70406353 0.12615941 0.444348910 #> 34  10.023614 0.1576340361 0.6216970964 0.78210182 0.06048809 0.947721819 #> 35  11.584755 0.4258746603 0.0042340204 0.03112690 0.53898954 0.351290324 #> 36  16.369986 0.3514485436 0.8470020872 0.39517534 0.53379761 0.563543642 #> 37  11.801550 0.2609182710 0.4988422689 0.53310193 0.41148769 0.722206617 #> 38   6.551574 0.8293840422 0.0536368384 0.33471232 0.14434654 0.669263439 #> 39   5.595860 0.2120036017 0.3893485165 0.65326158 0.23088470 0.062985555 #> 40  20.208615 0.3250550434 0.6858599265 0.91424940 0.60875733 0.879544277 #> 41  16.986450 0.6789210238 0.4106222112 0.45347471 0.80048570 0.211604108 #> 42  13.495114 0.6430051320 0.2600766481 0.92377445 0.09132057 0.781262683 #> 43  17.035465 0.4125444102 0.5177675276 0.98777078 0.46859677 0.309003265 #> 44  12.326859 0.1176328119 0.1946966413 0.62589850 0.68688279 0.884768495 #> 45  15.761771 0.6594399249 0.6072569215 0.23213414 0.43492972 0.110364238 #> 46  23.163308 0.9416496824 0.4092349561 0.99005480 0.82986953 0.113867485 #> 47  11.205558 0.9996683616 0.0294578678 0.53462244 0.88237138 0.299841770 #> 48  16.204456 0.5281595406 0.0010634891 0.81008305 0.97356747 0.924107481 #> 49  20.309441 0.6546782369 0.9711225589 0.86645495 0.64830269 0.427723981 #> 50  11.714903 0.5696514260 0.8825622501 0.29380554 0.05614968 0.047195012 #> 51  16.835248 0.9053750585 0.8535252616 0.20203872 0.73011502 0.242909296 #> 52  15.972953 0.9146019304 0.5891615695 0.50853111 0.44354240 0.356688302 #> 53  12.931350 0.3218688134 0.7612053347 0.73249181 0.45506004 0.070664430 #> 54  11.437905 0.3383209873 0.5550955092 0.45884185 0.45195129 0.258999986 #> 55   9.533960 0.3777005726 0.6860220742 0.38480090 0.11102878 0.201999931 #> 56   8.106522 0.9152705607 0.1164152857 0.11095753 0.08064474 0.212551820 #> 57  10.366087 0.8287820488 0.1184740260 0.32069635 0.31668340 0.694759363 #> 58  16.214461 0.9444349702 0.9365332325 0.43044472 0.94069411 0.633837986 #> 59  12.238676 0.1867862260 0.9565980940 0.54563143 0.57530196 0.237179739 #> 60  17.689560 0.4802156268 0.9164127647 0.51170095 0.71697276 0.138801176 #> 61   2.320966 0.2689777846 0.0007479317 0.41833439 0.15742279 0.126832403 #> 62  13.735266 0.4354642837 0.5360080854 0.36761624 0.31375840 0.706044929 #> 63  15.009681 0.0625840209 0.5439596830 0.86482505 0.83520194 0.608523829 #> 64  20.744012 0.3366812817 0.8265306321 0.87867310 0.78557594 0.477584738 #> 65  12.108408 0.5619351428 0.3660433823 0.39835940 0.45182194 0.250936965 #> 66  14.271105 0.6923129486 0.1326507980 0.84774744 0.78260741 0.218694113 #> 67  11.190654 0.1265436679 0.7145354096 0.36338261 0.53980688 0.508063156 #> 68  16.025768 0.5177793652 0.9832966432 0.68576940 0.43944972 0.190326528 #> 69  24.789005 0.6388091939 0.3776578177 0.98700774 0.84541431 0.951850409 #> 70   9.185519 0.0463474730 0.2209118321 0.50158703 0.46888338 0.823391459 #> 71   7.108708 0.2081563191 0.1640034495 0.46008040 0.28993239 0.618096247 #> 72  12.394803 0.2881255990 0.1692087383 0.37472480 0.70474861 0.648348246 #> 73  15.439979 0.4617162470 0.7853772915 0.90474155 0.18388422 0.262976428 #> 74  13.130026 0.4069326075 0.6049174396 0.98160203 0.09183642 0.097967924 #> 75  19.067879 0.7198746817 0.9837067495 0.24622017 0.58417129 0.782056808 #> 76  18.571389 0.4783525530 0.6985027203 0.54063990 0.65038579 0.681180339 #> 77  18.058464 0.8916681909 0.3719108894 0.47872891 0.60925668 0.674633251 #> 78   4.790314 0.0246532848 0.1542579043 0.42178781 0.44500275 0.037436911 #> 79  23.331516 0.6351153189 0.5481393081 0.04448537 0.64214677 0.790769406 #> 80  17.270832 0.3908880984 0.7231449513 0.63429824 0.72586831 0.392556404 #> 81  16.783845 0.5376661033 0.5836053693 0.36974378 0.72212535 0.162541629 #> 82  16.809608 0.7452690604 0.5157998072 0.59968251 0.25374419 0.936242811 #> 83   8.672745 0.1479747796 0.7217902243 0.77612701 0.36192930 0.048533057 #> 84  15.491656 0.1909503259 0.6034291473 0.73234764 0.97781434 0.179092183 #> 85   8.849248 0.3254722552 0.1843186312 0.19070342 0.42697828 0.165738771 #> 86   9.423387 0.0394796270 0.7239926779 0.13016036 0.25472619 0.647701826 #> 87  14.954767 0.5934679159 0.8440855062 0.81376928 0.06636500 0.459419391 #> 88  14.940362 0.6241817074 0.8355207876 0.68256784 0.12848377 0.579249768 #> 89  22.904172 0.5443477246 0.7064004592 0.23747160 0.99472952 0.446649317 #> 90   4.553068 0.0027585044 0.7108768146 0.28378503 0.21110891 0.299774076 #> 91  13.588892 0.9419699602 0.8855582720 0.64001952 0.35364491 0.938302146 #> 92   7.685669 0.1348288120 0.0441270615 0.16040167 0.21688171 0.571468831 #> 93  19.438779 0.6910544815 0.8454461338 0.81100623 0.54850378 0.458284137 #> 94  16.092476 0.7715629931 0.1065962985 0.99087681 0.66833139 0.399829024 #> 95  16.937315 0.6247570168 0.3522469536 0.58727770 0.87004411 0.353819617 #> 96  17.355054 0.8089950338 0.2592346051 0.58606783 0.76391437 0.714789014 #> 97   9.297988 0.6508365592 0.2403352042 0.49607992 0.12195164 0.641367927 #> 98  11.444188 0.2195732470 0.9544442415 0.63417187 0.19763729 0.621912588 #> 99  15.596308 0.7400014549 0.2873893159 0.22290774 0.31125073 0.934812914 #> 100 22.280968 0.4325508266 0.8760279566 0.46124819 0.88522120 0.853565969 #>              x6          x7         x8           x9        x10 #> 1   0.034242923 0.708089868 0.35914147 0.0610777270 0.22758428 #> 2   0.596107564 0.486425376 0.49329318 0.8551026261 0.43574008 #> 3   0.285908719 0.213685652 0.81126283 0.5519285847 0.83989131 #> 4   0.293156812 0.882510883 0.22718654 0.4651124007 0.64320816 #> 5   0.012705019 0.948371802 0.63928203 0.3378157120 0.32491792 #> 6   0.422165087 0.246071426 0.03615783 0.2795106776 0.71561663 #> 7   0.120269010 0.572805416 0.80556467 0.7345445950 0.73703060 #> 8   0.504527518 0.369914019 0.29122099 0.9650976271 0.26642593 #> 9   0.007521316 0.600617972 0.93391782 0.1898512354 0.69748546 #> 10  0.433976179 0.753366186 0.95327126 0.5203839843 0.13945654 #> 11  0.342134999 0.590422563 0.26271290 0.0611708523 0.37207212 #> 12  0.776205650 0.188571413 0.09173083 0.6422129232 0.28489947 #> 13  0.737612485 0.106413301 0.69908908 0.8835501899 0.02540059 #> 14  0.626222877 0.047179515 0.51425558 0.3463421324 0.15171488 #> 15  0.955695485 0.186753943 0.13663220 0.6762772684 0.59742975 #> 16  0.172546203 0.376719295 0.38715997 0.0125030046 0.54510263 #> 17  0.545021115 0.484789640 0.36758738 0.4416310841 0.22442658 #> 18  0.538295767 0.892354126 0.78598531 0.0343003345 0.26576790 #> 19  0.787723745 0.208301702 0.63139955 0.4674016791 0.25383709 #> 20  0.396561470 0.085427377 0.14193047 0.0041771673 0.96478442 #> 21  0.630536117 0.070383406 0.35941601 0.9448859505 0.46534421 #> 22  0.972894424 0.633558517 0.04530535 0.6375728617 0.73293406 #> 23  0.039641326 0.655676758 0.59222664 0.5741242785 0.05137181 #> 24  0.517838627 0.033208641 0.69524889 0.6965280552 0.90342846 #> 25  0.659225761 0.711370954 0.22926428 0.4074910728 0.02295865 #> 26  0.132956168 0.321289820 0.30945442 0.6835767005 0.31565006 #> 27  0.618167999 0.829285606 0.24049369 0.7298645473 0.54870292 #> 28  0.557701408 0.632464110 0.26868906 0.9848905541 0.96519751 #> 29  0.050808229 0.704465387 0.17299500 0.2793988590 0.90850278 #> 30  0.117315194 0.766360630 0.25847356 0.0828559217 0.11078018 #> 31  0.924157008 0.947811504 0.11520784 0.4628402672 0.51810978 #> 32  0.691690837 0.696576672 0.28472149 0.6932067138 0.28909726 #> 33  0.585145741 0.619186329 0.83799210 0.2473595894 0.74913218 #> 34  0.377643411 0.862922556 0.88198908 0.6925247158 0.40997901 #> 35  0.047371062 0.266061272 0.18454526 0.4830463436 0.18086288 #> 36  0.517291918 0.243575299 0.73558081 0.3417504118 0.68246246 #> 37  0.352946862 0.693149599 0.14363070 0.1045486750 0.41737379 #> 38  0.579649796 0.596710179 0.14520207 0.8336928731 0.86301916 #> 39  0.416965917 0.499558397 0.34470076 0.6475775053 0.04587891 #> 40  0.493167195 0.583622808 0.08443853 0.5942029294 0.15718454 #> 41  0.170384483 0.874281158 0.70761097 0.3040392618 0.14285383 #> 42  0.821086831 0.946794922 0.71313778 0.6325784195 0.55167329 #> 43  0.166999853 0.243589720 0.75084571 0.2689357174 0.25884974 #> 44  0.252969695 0.853858619 0.13020640 0.8448705720 0.87985808 #> 45  0.109633006 0.900220604 0.67633549 0.0168415420 0.75819330 #> 46  0.752872009 0.094513787 0.24641105 0.9307651916 0.36220957 #> 47  0.414518373 0.303107897 0.79306630 0.1548446179 0.20261637 #> 48  0.164274446 0.929899182 0.54470920 0.6314759830 0.25484556 #> 49  0.443809730 0.115665130 0.43970373 0.0353378267 0.87141381 #> 50  0.511488160 0.699254848 0.71063872 0.3781803669 0.83220172 #> 51  0.670928738 0.985215642 0.44290613 0.7118906244 0.40738102 #> 52  0.426001019 0.450633260 0.21228880 0.6114282946 0.23299247 #> 53  0.404537401 0.350622531 0.32384877 0.6979654906 0.24376099 #> 54  0.836621791 0.424080716 0.44632980 0.7862614230 0.70039763 #> 55  0.047172359 0.639840494 0.93305562 0.5415839397 0.30996131 #> 56  0.742328340 0.900150308 0.90837021 0.9925867668 0.26425059 #> 57  0.628580088 0.200577693 0.66036661 0.8578269284 0.31954179 #> 58  0.647300746 0.290988813 0.88610383 0.6013091863 0.99704871 #> 59  0.611986624 0.764279517 0.16331195 0.4026571792 0.65303878 #> 60  0.432625725 0.317979577 0.57190554 0.8151451547 0.06493345 #> 61  0.262366948 0.003992743 0.61654453 0.8046097308 0.73452569 #> 62  0.632444909 0.282399718 0.03126944 0.4877454117 0.92764269 #> 63  0.168103796 0.374801098 0.59942496 0.9299545551 0.57508326 #> 64  0.538680434 0.105743600 0.33625236 0.5762514903 0.37320879 #> 65  0.406551675 0.448441658 0.73176304 0.6472766520 0.06112425 #> 66  0.434686203 0.778510033 0.07953886 0.0003732827 0.49847027 #> 67  0.171017120 0.054072363 0.48412030 0.1010017192 0.23735809 #> 68  0.960915104 0.996568874 0.74783007 0.3287396773 0.83769274 #> 69  0.114367873 0.676393326 0.87083452 0.0801869438 0.97321203 #> 70  0.845674331 0.998511230 0.28930782 0.8951015933 0.75409960 #> 71  0.236174762 0.897463962 0.91057811 0.3170280487 0.66825403 #> 72  0.103356488 0.882108086 0.92159107 0.8556554778 0.78922504 #> 73  0.950230394 0.163734372 0.08825122 0.1731632191 0.90219313 #> 74  0.922517024 0.708412708 0.12089556 0.1927078371 0.15004643 #> 75  0.475061484 0.674637960 0.99018488 0.4840292903 0.20470819 #> 76  0.555780485 0.547723550 0.50100064 0.7315694520 0.49782261 #> 77  0.923358585 0.090754932 0.61106268 0.8990699153 0.10081324 #> 78  0.971798369 0.162182079 0.66534366 0.9558014688 0.91095628 #> 79  0.401708246 0.426679686 0.18814570 0.8032109921 0.08995544 #> 80  0.196741019 0.986763639 0.82722021 0.1786617143 0.01899216 #> 81  0.462164629 0.353265165 0.26879851 0.9008497326 0.05938888 #> 82  0.038918576 0.139789863 0.16585021 0.7366295452 0.81893303 #> 83  0.096510025 0.767528786 0.68874944 0.8194924979 0.34656378 #> 84  0.212969644 0.399658867 0.38180739 0.0589272704 0.72287816 #> 85  0.663871369 0.961870601 0.09616278 0.4503492787 0.78193040 #> 86  0.956607925 0.490030340 0.84577716 0.2624837207 0.54147464 #> 87  0.355419232 0.110987839 0.70473588 0.7271480360 0.35262759 #> 88  0.885159231 0.446340722 0.10877450 0.6382283943 0.45124294 #> 89  0.697324503 0.054131986 0.08702338 0.0186577390 0.84914334 #> 90  0.792573904 0.137287467 0.41453144 0.6244785439 0.02352309 #> 91  0.724002579 0.913146948 0.53844482 0.3332280456 0.70290222 #> 92  0.488631977 0.896673730 0.31123061 0.1474314202 0.10678558 #> 93  0.015908889 0.837059021 0.53906593 0.3760554059 0.11756390 #> 94  0.785463817 0.141332611 0.73425765 0.3223124736 0.78057825 #> 95  0.206332984 0.361111816 0.95616994 0.7208354436 0.95605403 #> 96  0.120416545 0.355863324 0.66917523 0.6672515746 0.60843793 #> 97  0.704068359 0.377924406 0.85128665 0.2099642872 0.34120736 #> 98  0.962544315 0.795774869 0.12637500 0.1922181458 0.20560801 #> 99  0.396618249 0.696234760 0.82306710 0.4727696877 0.50951772 #> 100 0.954556089 0.140891456 0.78722637 0.5780899401 0.80233188"},{"path":"https://koalaverse.github.io/vip/reference/get_feature_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract feature names — get_feature_names","title":"Extract feature names — get_feature_names","text":"Extract predictor names fitted model.","code":""},{"path":"https://koalaverse.github.io/vip/reference/get_feature_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract feature names — get_feature_names","text":"","code":"get_feature_names(object, ...)"},{"path":"https://koalaverse.github.io/vip/reference/get_feature_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract feature names — get_feature_names","text":"object appropriate fitted model object. ... Additional optional arguments.","code":""},{"path":"https://koalaverse.github.io/vip/reference/list_metrics.html","id":null,"dir":"Reference","previous_headings":"","what":"List metrics — list_metrics","title":"List metrics — list_metrics","text":"List available performance metrics.","code":""},{"path":"https://koalaverse.github.io/vip/reference/list_metrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List metrics — list_metrics","text":"","code":"list_metrics()"},{"path":"https://koalaverse.github.io/vip/reference/list_metrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List metrics — list_metrics","text":"data frame following columns: metric - optimization tuning metric; description - brief description metric; task - whether metric suitable regression classification; smaller_is_better - logical indicating whether smaller value metric considered better. yardstick_function - name corresponding function yardstick package.","code":""},{"path":"https://koalaverse.github.io/vip/reference/list_metrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List metrics — list_metrics","text":"","code":"(metrics <- list_metrics()) #>          metric                               description #> 1      accuracy                   Classification accuracy #> 2  bal_accuracy          Balanced classification accuracy #> 3        youden Youden;'s index (or Youden's J statistic) #> 4       roc_auc                      Area under ROC curve #> 5        pr_auc    Area under precision-recall (PR) curve #> 6       logloss                                  Log loss #> 7         brier                               Brier score #> 8           mae                       Mean absolute error #> 9          mape            Mean absolute percentage error #> 10         rmse                   Root mean squared error #> 11          rsq                   R-squared (correlation) #> 12     rsq_trad                   R-squared (traditional) #>                                task smaller_is_better yardstick_function #> 1  Binary/multiclass classification             FALSE       accuracy_vec #> 2  Binary/multiclass classification             FALSE   bal_accuracy_vec #> 3  Binary/multiclass classification             FALSE            j_index #> 4             Binary classification             FALSE        roc_auc_vec #> 5             Binary classification             FALSE         pr_auc_vec #> 6  Binary/multiclass classification              TRUE    mn_log_loss_vec #> 7  Binary/multiclass classification              TRUE    brier_class_vec #> 8                        Regression              TRUE            mae_vec #> 9                        Regression              TRUE           mape_vec #> 10                       Regression              TRUE           rmse_vec #> 11                       Regression             FALSE            rsq_vec #> 12                       Regression             FALSE       rsq_trad_vec metrics[metrics$task == \"Multiclass classification\", ] #> [1] metric             description        task               smaller_is_better  #> [5] yardstick_function #> <0 rows> (or 0-length row.names)"},{"path":"https://koalaverse.github.io/vip/reference/titanic.html","id":null,"dir":"Reference","previous_headings":"","what":"Survival of Titanic passengers — titanic","title":"Survival of Titanic passengers — titanic","text":"data set containing survival outcome, passenger class, age, sex, number family members large number passengers aboard ill-fated Titanic.","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survival of Titanic passengers — titanic","text":"","code":"titanic"},{"path":"https://koalaverse.github.io/vip/reference/titanic.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Survival of Titanic passengers — titanic","text":"data frame 1309 observations following 6 variables: survived - binary levels \"yes\" survived \"\" otherwise; pclass - integer giving corresponding passenger (.e., ticket) class values 1--3; age - age years corresponding passenger (263 missing values); age - factor giving sex passenger levels \"male\" \"female\"; sibsp - integer giving number siblings/spouses aboard passenger (ranges 0--8); parch - integer giving number parents/children aboard passenger (ranges 0--9).","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Survival of Titanic passengers — titanic","text":"https://hbiostat.org/data/.","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Survival of Titanic passengers — titanic","text":"mentioned column description, age contains 263 NAs (missing values). complete version (versions) data set, see titanic_mice.","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic_mice.html","id":null,"dir":"Reference","previous_headings":"","what":"Survival of Titanic passengers — titanic_mice","title":"Survival of Titanic passengers — titanic_mice","text":"titanic data set contains 263 missing values (.e., NA's) age column. version data contains imputed values age column using multivariate imputation chained equations via mice package. Consequently, list containing 11 imputed versions observations containd titanic data frame; completed data sets dimension column structure titanic.","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic_mice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Survival of Titanic passengers — titanic_mice","text":"","code":"titanic_mice"},{"path":"https://koalaverse.github.io/vip/reference/titanic_mice.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Survival of Titanic passengers — titanic_mice","text":"object class mild (inherits list) length 21.","code":""},{"path":"https://koalaverse.github.io/vip/reference/titanic_mice.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Survival of Titanic passengers — titanic_mice","text":"Greenwell, Brandon M. (2022). Tree-Based Methods Statistical Learning R. CRC Press.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable importance — vi","title":"Variable importance — vi","text":"Compute variable importance scores predictors model.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable importance — vi","text":"","code":"vi(object, ...)  # S3 method for default vi(   object,   method = c(\"model\", \"firm\", \"permute\", \"shap\"),   feature_names = NULL,   abbreviate_feature_names = NULL,   sort = TRUE,   decreasing = TRUE,   scale = FALSE,   rank = FALSE,   ... )"},{"path":"https://koalaverse.github.io/vip/reference/vi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable importance — vi","text":"object fitted model object (e.g., randomForest object) object inherits class \"vi\". ... Additional optional arguments passed vi_model, vi_firm, vi_permute, vi_shap; see respective help pages details. method Character string specifying type variable importance (VI) compute. Current options : \"model\" (default), model-specific VI scores (see vi_model details). \"firm\", variance-based VI scores (see vi_firm details). \"permute\", permutation-based VI scores (see vi_permute details). \"shap\", Shapley-based VI scores (see vi_shap details). feature_names Character string giving names predictor variables (.e., features) interest. abbreviate_feature_names Integer specifying length abbreviate feature names. Default NULL results abbreviation (.e., full name feature printed). sort Logical indicating whether order sort variable importance scores. Default TRUE. decreasing Logical indicating whether variable importance scores sorted descending (TRUE) ascending (FALSE) order importance. Default TRUE. scale Logical indicating whether scale variable importance scores largest 100. Default FALSE. rank Logical indicating whether rank variable importance scores (.e., convert integer ranks). Default FALSE. Potentially useful comparing variable importance scores across different models using different methods.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variable importance — vi","text":"tidy data frame (.e., tibble object) two columns: Variable - corresponding feature name; Importance - associated importance, computed average change performance random permutation (permutations, nsim > 1) feature question. lm/glm-like objects, whenever method = \"model\", sign (.e., POS/NEG) original coefficient also included column called Sign. method = \"permute\" nsim > 1, additional column (StDev) containing standard deviation individual permutation scores feature also returned; helps assess stability/variation individual permutation importance feature.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable importance — vi","text":"","code":"# # A projection pursuit regression example #  # Load the sample data data(mtcars)  # Fit a projection pursuit regression model mtcars.ppr <- ppr(mpg ~ ., data = mtcars, nterms = 1)  # Prediction wrapper that tells vi() how to obtain new predictions from your # fitted model pfun <- function(object, newdata) predict(object, newdata = newdata)  # Compute permutation-based variable importance scores set.seed(1434)  # for reproducibility (vis <- vi(mtcars.ppr, method = \"permute\", target = \"mpg\", nsim = 10,            metric = \"rmse\", pred_wrapper = pfun, train = mtcars)) #> # A tibble: 10 × 3 #>    Variable Importance   StDev #>    <chr>         <dbl>   <dbl> #>  1 wt         3.17     0.374   #>  2 hp         2.18     0.462   #>  3 gear       0.755    0.367   #>  4 qsec       0.674    0.240   #>  5 cyl        0.462    0.158   #>  6 am         0.173    0.144   #>  7 vs         0.0999   0.0605  #>  8 drat       0.0265   0.0564  #>  9 carb       0.00898  0.00885 #> 10 disp      -0.000824 0.00744  # Plot variable importance scores vip(vis, include_type = TRUE, all_permutations = TRUE,     geom = \"point\", aesthetics = list(color = \"forestgreen\", size = 3))   # # A binary classification example # if (FALSE) { library(rpart)  # for classification and regression trees  # Load Wisconsin breast cancer data; see ?mlbench::BreastCancer for details data(BreastCancer, package = \"mlbench\") bc <- subset(BreastCancer, select = -Id)  # for brevity  # Fit a standard classification tree set.seed(1032)  # for reproducibility tree <- rpart(Class ~ ., data = bc, cp = 0)  # Prune using 1-SE rule (e.g., use `plotcp(tree)` for guidance) cp <- tree$cptable cp <- cp[cp[, \"nsplit\"] == 2L, \"CP\"] tree2 <- prune(tree, cp = cp)  # tree with three splits  # Default tree-based VIP vip(tree2)  # Computing permutation importance requires a prediction wrapper. For # classification, the return value depends on the chosen metric; see # `?vip::vi_permute` for details. pfun <- function(object, newdata) {   # Need vector of predicted class probabilities when using  log-loss metric   predict(object, newdata = newdata, type = \"prob\")[, \"malignant\"] }  # Permutation-based importance (note that only the predictors that show up # in the final tree have non-zero importance) set.seed(1046)  # for reproducibility vi(tree2, method = \"permute\", nsim = 10, target = \"Class\", train = bc,    metric = \"logloss\", pred_wrapper = pfun, reference_class = \"malignant\")  # Equivalent (but not sorted) set.seed(1046)  # for reproducibility vi_permute(tree2, nsim = 10, target = \"Class\", metric = \"logloss\",            pred_wrapper = pfun, reference_class = \"malignant\") }"},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":null,"dir":"Reference","previous_headings":"","what":"Variance-based variable importance — vi_firm","title":"Variance-based variable importance — vi_firm","text":"Compute variance-based variable importance (VI) scores using simple feature importance ranking measure (FIRM) approach; details, see Greenwell et al. (2018) Scholbeck et al. (2019).","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variance-based variable importance — vi_firm","text":"","code":"vi_firm(object, ...)  # S3 method for default vi_firm(   object,   feature_names = NULL,   train = NULL,   var_fun = NULL,   var_continuous = stats::sd,   var_categorical = function(x) diff(range(x))/4,   ... )"},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variance-based variable importance — vi_firm","text":"object fitted model object (e.g., randomForest object). ... Additional arguments passed pdp::partial() function (e.g., ice = TRUE, prob = TRUE, prediction wrapper via pred.fun argument); see ?pdp::partial details useful arguments. feature_names Character string giving names predictor variables (.e., features) interest. NULL (default) internal get_feature_names() function called try extract automatically. good practice always specify argument. train matrix-like R object (e.g., data frame matrix) containing training data. NULL (default) internal get_training_data() function called try extract automatically. good practice always specify argument. var_fun Deprecated; use var_continuous var_categorical instead. var_continuous Function used quantify variability effects continuous features. Defaults using sample standard deviation (.e., stats::sd()). var_categorical Function used quantify variability effects categorical features. Defaults using range divided four; , function(x) diff(range(x)) / 4.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Variance-based variable importance — vi_firm","text":"tidy data frame (.e., tibble object) two columns: Variable - corresponding feature name; Importance - associated importance, computed described Greenwell et al. (2018).","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Variance-based variable importance — vi_firm","text":"approach based quantifying relative \"flatness\" effect feature assumes user familiarity pdp::partial() function.  Feature effects can assessed using partial dependence (PD) plots (Friedman, 2001) individual conditional expectation (ICE) plots (Goldstein et al., 2014). methods model-agnostic can applied supervised learning algorithm. default, relative \"flatness\" defined computing standard deviation y-axis values feature effect plot numeric features; categorical features, default use range divided 4. can changed via var_continuous var_categorical arguments. See Greenwell et al. (2018) details additional examples.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Variance-based variable importance — vi_firm","text":"approach can provide misleading results presence interaction effects (akin interpreting main effect coefficients linear higher level interaction effects).","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Variance-based variable importance — vi_firm","text":"J. H. Friedman. Greedy function approximation: gradient boosting machine. Annals Statistics, 29: 1189-1232, 2001. Goldstein, ., Kapelner, ., Bleich, J., Pitkin, E., Peeking Inside Black Box: Visualizing Statistical Learning Plots Individual Conditional Expectation. (2014) Journal Computational Graphical Statistics, 24(1): 44-65, 2015. Greenwell, B. M., Boehmke, B. C., McCarthy, . J. Simple Effective Model-Based Variable Importance Measure. arXiv preprint arXiv:1805.04755 (2018). Scholbeck, C. . Scholbeck, Molnar, C.,  Heumann C., Bischl, B., Casalicchio, G. Sampling, Intervention, Prediction, Aggregation: Generalized Framework Model-Agnostic Interpretations. arXiv preprint arXiv:1904.03959 (2019).","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_firm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variance-based variable importance — vi_firm","text":"","code":"if (FALSE) { # # A projection pursuit regression example #  # Load the sample data data(mtcars)  # Fit a projection pursuit regression model mtcars.ppr <- ppr(mpg ~ ., data = mtcars, nterms = 1)  # Compute variable importance scores using the FIRM method; note that the pdp # package knows how to work with a \"ppr\" object, so there's no need to pass # the training data or a prediction wrapper, but it's good practice. vi_firm(mtcars.ppr, train = mtcars)  # For unsopported models, need to define a prediction wrapper; this approach # will work for ANY model (supported or unsupported, so better to just always # define it pass it) pfun <- function(object, newdata) {   # To use partial dependence, this function needs to return the AVERAGE   # prediction (for ICE, simply omit the averaging step)   mean(predict(object, newdata = newdata)) }  # Equivalent to the previous results (but would work if this type of model # was not explicitly supported) vi_firm(mtcars.ppr, pred.fun = pfun, train = mtcars)  # Equivalent VI scores, but the output is sorted by default vi(mtcars.ppr, method = \"firm\")  # Use MAD to estimate variability of the partial dependence values vi_firm(mtcars.ppr, var_continuous = stats::mad)  # Plot VI scores vip(mtcars.ppr, method = \"firm\", train = mtcars, pred.fun = pfun) }"},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Model-specific variable importance — vi_model","title":"Model-specific variable importance — vi_model","text":"Compute model-specific variable importance scores predictors fitted model.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model-specific variable importance — vi_model","text":"","code":"vi_model(object, ...)  # S3 method for default vi_model(object, ...)  # S3 method for C5.0 vi_model(object, type = c(\"usage\", \"splits\"), ...)  # S3 method for train vi_model(object, ...)  # S3 method for cubist vi_model(object, ...)  # S3 method for earth vi_model(object, type = c(\"nsubsets\", \"rss\", \"gcv\"), ...)  # S3 method for gbm vi_model(object, type = c(\"relative.influence\", \"permutation\"), ...)  # S3 method for glmnet vi_model(object, lambda = NULL, ...)  # S3 method for cv.glmnet vi_model(object, lambda = NULL, ...)  # S3 method for H2OBinomialModel vi_model(object, ...)  # S3 method for H2OMultinomialModel vi_model(object, ...)  # S3 method for H2ORegressionModel vi_model(object, ...)  # S3 method for lgb.Booster vi_model(object, type = c(\"gain\", \"cover\", \"frequency\"), ...)  # S3 method for mixo_pls vi_model(object, ncomp = NULL, ...)  # S3 method for mixo_spls vi_model(object, ncomp = NULL, ...)  # S3 method for WrappedModel vi_model(object, ...)  # S3 method for Learner vi_model(object, ...)  # S3 method for nn vi_model(object, type = c(\"olden\", \"garson\"), ...)  # S3 method for nnet vi_model(object, type = c(\"olden\", \"garson\"), ...)  # S3 method for RandomForest vi_model(object, type = c(\"accuracy\", \"auc\"), ...)  # S3 method for constparty vi_model(object, ...)  # S3 method for cforest vi_model(object, ...)  # S3 method for mvr vi_model(object, ...)  # S3 method for mixo_pls vi_model(object, ncomp = NULL, ...)  # S3 method for mixo_spls vi_model(object, ncomp = NULL, ...)  # S3 method for WrappedModel vi_model(object, ...)  # S3 method for Learner vi_model(object, ...)  # S3 method for randomForest vi_model(object, ...)  # S3 method for ranger vi_model(object, ...)  # S3 method for rpart vi_model(object, ...)  # S3 method for mlp vi_model(object, type = c(\"olden\", \"garson\"), ...)  # S3 method for ml_model_decision_tree_regression vi_model(object, ...)  # S3 method for ml_model_decision_tree_classification vi_model(object, ...)  # S3 method for ml_model_gbt_regression vi_model(object, ...)  # S3 method for ml_model_gbt_classification vi_model(object, ...)  # S3 method for ml_model_generalized_linear_regression vi_model(object, ...)  # S3 method for ml_model_linear_regression vi_model(object, ...)  # S3 method for ml_model_random_forest_regression vi_model(object, ...)  # S3 method for ml_model_random_forest_classification vi_model(object, ...)  # S3 method for lm vi_model(object, type = c(\"stat\", \"raw\"), ...)  # S3 method for model_fit vi_model(object, ...)  # S3 method for workflow vi_model(object, ...)  # S3 method for xgb.Booster vi_model(object, type = c(\"gain\", \"cover\", \"frequency\"), ...)"},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Model-specific variable importance — vi_model","text":"Johan Bring (1994) Standardize Regression Coefficients, American Statistician, 48:3, 209-213, DOI: 10.1080/00031305.1994.10476059.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model-specific variable importance — vi_model","text":"object fitted model object (e.g., randomForest object). See details section see variable importance computed supported model types. ... Additional optional arguments passed methods. See details section arguments can passed specific object types. type Character string specifying type variable importance return (used models). See details section methods argument applies . lambda Numeric value penalty parameter glmnet model (equivalent s argument coef.glmnet). See section glmnet details . ncomp integer number partial least squares components used importance calculations. components requested used model, model's components used.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model-specific variable importance — vi_model","text":"tidy data frame (.e., tibble object) two columns: Variable - corresponding feature name; Importance - associated importance, computed average change performance random permutation (permutations, nsim > 1) feature question. lm/glm-like objects, sign (.e., POS/NEG) original coefficient also included column called Sign.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model-specific variable importance — vi_model","text":"Computes model-specific variable importance scores depending class object: C5.0 - Variable importance measured determining percentage training set samples fall terminal nodes split. example, predictor first split automatically importance measurement 100 percent since samples affected split. predictors may used frequently splits, terminal nodes cover handful training set samples, importance scores may close zero. strategy applied rule-based models boosted versions model. underlying function can also return number times predictor involved split using option metric = \"usage\". See C5imp details. cubist - Cubist output contains variable usage statistics. gives percentage times variable used condition /linear model. Note output probably inconsistent rules shown output summary.cubist. split tree, Cubist saves linear model (feature selection) allowed terms variable used current split split . Quinlan (1992) discusses smoothing algorithm model prediction linear combination parent child model along tree. , final prediction function linear models initial node terminal node. percentages shown Cubist output reflects models involved prediction (opposed terminal models shown output). variable importance used linear combination usage rule conditions model. See summary.cubist varImp details. glmnet - Similar (generalized) linear models, absolute value coefficients returned specific model. important features  (hence, estimated coefficients) standardized prior fitting model. can specify coefficients return passing specific value penalty parameter via lambda argument (equivalent s argument coef.glmnet). default, lambda = NULL coefficients corresponding final penalty value sequence returned; words, ALWAYS SPECIFY lambda! cv.glmnet objects, largest value lambda error within one standard error minimum used default. multinomial response, coefficients corresponding first class used; , first component coef.glmnet. cforest - Variable importance measured way similar computed importance. Besides standard version, conditional version available adjusts correlations predictor variables. conditional = TRUE, importance variable computed permuting within grid defined predictors associated (1 - p-value greater threshold) variable interest. resulting variable importance score conditional sense beta coefficients regression models, represents effect variable main effects interactions. See Strobl et al. (2008) details. Note, however, random forest results subject random variation. Thus, interpreting importance ranking, check whether ranking achieved different random seed - otherwise increase number trees ntree ctree_control. Note presence missings predictor variables procedure described Hapfelmeier et al. (2012) performed. See varimp details. earth - earth package uses three criteria estimating variable importance MARS model (see evimp details): nsubsets criterion (type = \"nsubsets\") counts number model subsets include feature. Variables included subsets considered important. criterion used summary.earth print variable importance. \"subsets\" mean subsets terms generated earth()'s backward pass. one subset model size (one size selected model) subset best set terms model size. (subsets specified $prune.terms component earth()'s return value.) subsets smaller equal size final model used estimating variable importance. default method used vi_model. rss criterion (type = \"rss\") first calculates decrease RSS subset relative previous subset earth()’s backward pass. (multiple response models, RSS's calculated responses.) variable sums decreases subsets include variable. Finally, ease interpretation summed decreases scaled largest summed decrease 100. Variables cause larger net decreases RSS considered important. gcv criterion (type = \"gcv\") similar rss approach, uses GCV statistic instead RSS. Note adding variable can sometimes increase GCV. (Adding variable deleterious effect model, measured terms estimated predictive power unseen data.) happens often enough, variable can negative total importance, thus appear less important unused variables. gbm - Variable importance computed using one two approaches (See summary.gbm details): standard approach (type = \"relative.influence\") described Friedman (2001). distribution = \"gaussian\" returns reduction squared error attributable variable. loss functions returns reduction attributable variable sum squared error predicting gradient iteration. describes relative influence variable reducing loss function. default method used vi_model. experimental permutation-based approach (type = \"permutation\"). method randomly permutes predictor variable time computes associated reduction predictive performance. similar variable importance measures Leo Breiman uses random forests, gbm currently computes using entire training dataset (--bag observations). H2OModel - See h2o.varimp visit https://docs.h2o.ai/h2o/latest-stable/h2o-docs/variable-importance.html details. nnet - Two popular methods constructing variable importance scores neural networks Garson algorithm (Garson 1991), later modified Goh (1995), Olden algorithm (Olden et al. 2004). algorithms, basis importance scores network’s connection weights. Garson algorithm determines variable importance identifying weighted connections nodes interest. Olden’s algorithm, hand, uses product raw connection weights input output neuron sums product across hidden neurons. shown outperform Garson method various simulations. DNNs, similar method due Gedeon (1997) considers weights connecting input features first two hidden layers (simplicity speed); method can slow large networks.. implement Olden Garson algorithms, use type = \"olden\" type = \"garson\", respectively. See garson olden details. lm/glm - (generalized) linear models, variable importance typically based absolute value corresponding t-statistics (Bring, 1994). models, sign original coefficient also returned. default, type = \"stat\" used; however, inputs appropriately standardized raw coefficients can used type = \"raw\". Note Bring (1994) provides motivation using absolute value associated t-statistics. sparklyr - Spark ML library provides standard variable importance measures tree-based methods (e.g., random forests). See ml_feature_importances details. randomForest Random forests typically provide two measures variable importance. first measure computed permuting --bag (OOB) data: tree, prediction error OOB portion data recorded (error rate classification MSE regression). done permuting predictor variable. difference two averaged trees forest, normalized standard deviation differences. standard deviation differences equal 0 variable, division done (average almost always equal 0 case). second measure total decrease node impurities splitting variable, averaged trees. classification, node impurity measured Gini index. regression, measured residual sum squares. See importance details, including additional arguments can passed via ... argument vi_model. cforest - approach described cforest (package partykit) . See varimp varimpAUC (type = \"auc\") details. ranger - Variable importance ranger objects computed usual way random forests. approach used depends importance argument provided initial call ranger. See importance details. rpart - stated one rpart vignettes. variable may appear tree many times, either primary surrogate variable. overall measure variable importance sum goodness split measures split primary variable, plus \"goodness\" * (adjusted agreement) splits surrogate. Imagine two variables essentially duplicates ; count surrogates, split importance neither showing strongly . See rpart details. caret - Various model-specific model-agnostic approaches depend learning algorithm employed original call caret. See varImp details. xgboost - linear models, variable importance absolute magnitude estimated coefficients. reason, order obtain meaningful ranking importance linear model, features need scale (also want using either L1 L2 regularization). Otherwise, approach described Friedman (2001) gbms used. See xgb.importance details. tree models, can obtain three different types variable importance: Using type = \"gain\" (default) gives fractional contribution feature model based total gain corresponding feature's splits. Using type = \"cover\" gives number observations related feature. Using type = \"frequency\" gives percentages representing relative number times feature used throughout tree ensemble. lightgbm - xgboost models, except lgb.importance (method calls internally) additional argument, percentage, defaults TRUE, resulting VI scores shown relative percentage; pass percentage = FALSE call vi_model() produce VI scores lightgbm models raw scale.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Model-specific variable importance — vi_model","text":"Inspired caret's varImp function.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model-specific variable importance — vi_model","text":"","code":"if (FALSE) { # Basic example using imputed titanic data set t3 <- titanic_mice[[1L]]  # Fit a simple model set.seed(1449)  # for reproducibility bst <- lightgbm::lightgbm(   data = data.matrix(subset(t3, select = -survived)),   label = ifelse(t3$survived == \"yes\", 1, 0),   params = list(\"objective\" = \"binary\", \"force_row_wise\" = TRUE),   verbose = 0 )  # Compute VI scores vi(bst)  # defaults to `method = \"model\"` vi_model(bst)  # same as above  # Same as above (since default is `method = \"model\"`), but returns a plot vip(bst, geom = \"point\") vi_model(bst, type = \"cover\") vi_model(bst, type = \"cover\", percentage = FALSE)  # Compare to lightgbm::lgb.importance(bst) }"},{"path":"https://koalaverse.github.io/vip/reference/vi_permute.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation-based variable importance — vi_permute","title":"Permutation-based variable importance — vi_permute","text":"Compute permutation-based variable importance scores predictors model; details algorithm, see Greenwell Boehmke (2020).","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_permute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation-based variable importance — vi_permute","text":"","code":"vi_permute(object, ...)  # S3 method for default vi_permute(   object,   feature_names = NULL,   train = NULL,   target = NULL,   metric = NULL,   smaller_is_better = NULL,   type = c(\"difference\", \"ratio\"),   nsim = 1,   keep = TRUE,   sample_size = NULL,   sample_frac = NULL,   reference_class = NULL,   event_level = NULL,   pred_wrapper = NULL,   verbose = FALSE,   parallel = FALSE,   parallelize_by = c(\"features\", \"repetitions\"),   ... )"},{"path":"https://koalaverse.github.io/vip/reference/vi_permute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation-based variable importance — vi_permute","text":"object fitted model object (e.g., randomForest object). ... Additional optional arguments passed foreach (e.g., .packages .export). feature_names Character string giving names predictor variables (.e., features) interest. NULL (default) inferred train target arguments (see ). good practice always specify argument. train matrix-like R object (e.g., data frame matrix) containing training data. NULL (default) internal get_training_data() function called try extract automatically. good practice always specify argument. target Either character string giving name (position) target column train , train contains feature columns, vector containing target values used train object. metric Either function character string specifying performance metric use computing model performance (e.g., RMSE regression accuracy binary classification). metric function, requires two arguments, actual predicted, return single, numeric value. Ideally, metric used train object. See list_metrics() list built-metrics. smaller_is_better Logical indicating whether smaller value metric better. Default NULL. Must supplied metric user-supplied function. type Character string specifying compare baseline permuted performance metrics. Current options \"difference\" (default) \"ratio\". nsim Integer specifying number Monte Carlo replications perform. Default 1. nsim > 1, results replication simply averaged together (standard deviation also returned). keep Logical indicating whether keep individual permutation scores nsim repetitions. TRUE (default) individual variable importance scores stored attribute called \"raw_scores\". (used nsim > 1.) sample_size Integer specifying size random sample use Monte Carlo repetition. Default NULL (.e., use available training data). specified sample_frac. Can used reduce computation time large data sets. sample_frac Proportion specifying size random sample use Monte Carlo repetition. Default NULL (.e., use available training data). specified sample_size. Can used reduce computation time large data sets. reference_class Deprecated, use event_level instead. event_level String specifying factor level truth consider \"event\". Options \"first\" (default) \"second\". argument applicable binary classification metric one \"roc_auc\", \"pr_auc\", \"youden\". argument passed corresponding yardstick metric. pred_wrapper Prediction function requires two arguments, object newdata. output function determined metric used: Regression - numeric vector predicted outcomes. Binary classification - vector predicted class labels (e.g., using misclassification error) vector predicted class probabilities reference class (e.g., using log loss AUC). Multiclass classification - vector predicted class labels (e.g., using misclassification error) matrix/data frame predicted class probabilities class (e.g., using log loss AUC). verbose Logical indicating whether print information construction variable importance scores. Default FALSE. parallel Logical indicating whether run vi_permute() parallel (using backend provided foreach package). Default FALSE. TRUE, foreach-compatible backend must provided must provided. Note set.seed() work foreach's parellelized loops; workaround, see solution. parallelize_by Character string specifying whether parallelize across features (parallelize_by = \"features\") repetitions (parallelize_by = \"reps\"); latter useful whenever nsim > 1. Default \"features\".","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_permute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation-based variable importance — vi_permute","text":"tidy data frame (.e., tibble object) two columns: Variable - corresponding feature name; Importance - associated importance, computed average change performance random permutation (permutations, nsim > 1) feature question. nsim > 1, additional column (StDev) containing standard deviation individual permutation scores feature also returned; helps assess stability/variation individual permutation importance feature.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_permute.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation-based variable importance — vi_permute","text":"Brandon M. Greenwell Bradley C. Boehmke, R Journal (2020) 12:1, pages 343-366.","code":""},{"path":[]},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":null,"dir":"Reference","previous_headings":"","what":"SHAP-based variable importance — vi_shap","title":"SHAP-based variable importance — vi_shap","text":"Compute SHAP-based VI scores predictors model. See details .","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"SHAP-based variable importance — vi_shap","text":"","code":"vi_shap(object, ...)  # S3 method for default vi_shap(object, feature_names = NULL, train = NULL, ...)"},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"SHAP-based variable importance — vi_shap","text":"object fitted model object (e.g., randomForest object). ... Additional arguments passed fastshap::explain() (e.g., nsim =  30, adjust = TRUE, avprediction wrapper via pred_wrapper argument); see ?fastshap::explain details useful arguments. feature_names Character string giving names predictor variables (.e., features) interest. NULL (default) inferred train target arguments (see ). good practice always specify argument. train matrix-like R object (e.g., data frame matrix) containing training data. NULL (default) internal get_training_data() function called try extract automatically. good practice always specify argument.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"SHAP-based variable importance — vi_shap","text":"tidy data frame (.e., tibble object) two columns: Variable - corresponding feature name; Importance - associated importance, computed mean absolute Shapley value.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"SHAP-based variable importance — vi_shap","text":"approach computing VI scores based mean absolute value SHAP values feature; see, example, https://github.com/slundberg/shap references therein. Strumbelj, E., Kononenko, . Explaining prediction models individual predictions feature contributions. Knowledge information systems 41.3 (2014): 647-665.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vi_shap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"SHAP-based variable importance — vi_shap","text":"","code":"if (FALSE) { library(ggplot2)  # for theme_light() function library(xgboost)  # Simulate training data trn <- gen_friedman(500, sigma = 1, seed = 101)  # ?vip::gen_friedman  # Feature matrix X <- data.matrix(subset(trn, select = -y))  # matrix of feature values  # Fit an XGBoost model; hyperparameters were tuned using 5-fold CV set.seed(859)  # for reproducibility bst <- xgboost(X, label = trn$y, nrounds = 338, max_depth = 3, eta = 0.1,                verbose = 0)  # Construct VIP using \"exact\" SHAP values from XGBoost's internal Tree SHAP # functionality vip(bst, method = \"shap\", train = X, exact = TRUE, include_type = TRUE,     geom = \"point\", horizontal = FALSE,     aesthetics = list(color = \"forestgreen\", shape = 17, size = 5)) +   theme_light()  # Use Monte-Carlo approach, which works for any model; requires prediction # wrapper pfun_prob <- function(object, newdata) {  # prediction wrapper   # For Shapley explanations, this should ALWAYS return a numeric vector   predict(object, newdata = newdata, type = \"prob\")[, \"yes\"] }  # Compute Shapley-based VI scores set.seed(853)  # for reproducibility vi_shap(rfo, train = subset(t1, select = -survived), pred_wrapper = pfun_prob,         nsim = 30) ## # A tibble: 5 × 2 ## Variable Importance ##   <chr>         <dbl> ## 1 pclass       0.104 ## 2 age          0.0649 ## 3 sex          0.272 ## 4 sibsp        0.0260 ## 5 parch        0.0291 }"},{"path":"https://koalaverse.github.io/vip/reference/vip.html","id":null,"dir":"Reference","previous_headings":"","what":"Variable importance plots — vip","title":"Variable importance plots — vip","text":"Plot variable importance scores predictors model.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Variable importance plots — vip","text":"","code":"vip(object, ...)  # S3 method for default vip(   object,   num_features = 10L,   geom = c(\"col\", \"point\", \"boxplot\", \"violin\"),   mapping = NULL,   aesthetics = list(),   horizontal = TRUE,   all_permutations = FALSE,   jitter = FALSE,   include_type = FALSE,   ... )  # S3 method for model_fit vip(object, ...)  # S3 method for workflow vip(object, ...)  # S3 method for WrappedModel vip(object, ...)  # S3 method for Learner vip(object, ...)"},{"path":"https://koalaverse.github.io/vip/reference/vip.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Variable importance plots — vip","text":"object fitted model (e.g., class randomForest object) vi object. ... Additional optional arguments passed vi. num_features Integer specifying number variable importance scores plot. Default 10. geom Character string specifying type plot construct. currently available options described . geom = \"col\" uses geom_col construct bar chart variable importance scores. geom = \"point\" uses geom_point construct Cleveland dot plot variable importance scores. geom = \"boxplot\" uses geom_boxplot construct boxplot plot variable importance scores. option can permutation-based importance method nsim > 1 keep = TRUE; see vi_permute details. geom = \"violin\" uses geom_violin construct violin plot variable importance scores. option can permutation-based importance method nsim > 1 keep = TRUE; see vi_permute details. mapping Set aesthetic mappings created aes aes_. See example usage . aesthetics List specifying additional arguments passed layer. often aesthetics, used set aesthetic fixed value, likecolour = \"red\" size = 3. See example usage . horizontal Logical indicating whether plot importance scores x-axis (TRUE). Default TRUE. all_permutations Logical indicating whether plot permutation scores along average. Default FALSE. (used permutation scores nsim > 1.) jitter Logical indicating whether jitter raw permutation scores. Default FALSE. (used all_permutations = TRUE.) include_type Logical indicating whether include type variable importance computed axis label. Default FALSE.","code":""},{"path":"https://koalaverse.github.io/vip/reference/vip.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variable importance plots — vip","text":"","code":"# # A projection pursuit regression example using permutation-based importance #  # Load the sample data data(mtcars)  # Fit a projection pursuit regression model model <- ppr(mpg ~ ., data = mtcars, nterms = 1)  # Construct variable importance plot (permutation importance, in this case) set.seed(825)  # for reproducibility pfun <- function(object, newdata) predict(object, newdata = newdata) vip(model, method = \"permute\", train = mtcars, target = \"mpg\", nsim = 10,     metric = \"rmse\", pred_wrapper = pfun)   # Better yet, store the variable importance scores and then plot set.seed(825)  # for reproducibility vis <- vi(model, method = \"permute\", train = mtcars, target = \"mpg\",           nsim = 10, metric = \"rmse\", pred_wrapper = pfun) vip(vis, geom = \"point\", horiz = FALSE)  vip(vis, geom = \"point\", horiz = FALSE, aesthetics = list(size = 3))   # Plot unaggregated permutation scores (boxplot colored by feature) library(ggplot2)  # for `aes_string()` function vip(vis, geom = \"boxplot\", all_permutations = TRUE, jitter = TRUE,     mapping = aes_string(fill = \"Variable\"),     aesthetics = list(color = \"grey35\", size = 0.8)) #> Warning: `aes_string()` was deprecated in ggplot2 3.0.0. #> ℹ Please use tidy evaluation idioms with `aes()`. #> ℹ See also `vignette(\"ggplot2-in-packages\")` for more information.   # # A binary classification example # if (FALSE) { library(rpart)  # for classification and regression trees  # Load Wisconsin breast cancer data; see ?mlbench::BreastCancer for details data(BreastCancer, package = \"mlbench\") bc <- subset(BreastCancer, select = -Id)  # for brevity  # Fit a standard classification tree set.seed(1032)  # for reproducibility tree <- rpart(Class ~ ., data = bc, cp = 0)  # Prune using 1-SE rule (e.g., use `plotcp(tree)` for guidance) cp <- tree$cptable cp <- cp[cp[, \"nsplit\"] == 2L, \"CP\"] tree2 <- prune(tree, cp = cp)  # tree with three splits  # Default tree-based VIP vip(tree2)  # Computing permutation importance requires a prediction wrapper. For # classification, the return value depends on the chosen metric; see # `?vip::vi_permute` for details. pfun <- function(object, newdata) {   # Need vector of predicted class probabilities when using  log-loss metric   predict(object, newdata = newdata, type = \"prob\")[, \"malignant\"] }  # Permutation-based importance (note that only the predictors that show up # in the final tree have non-zero importance) set.seed(1046)  # for reproducibility vip(tree2, method = \"permute\", nsim = 10, target = \"Class\",     metric = \"logloss\", pred_wrapper = pfun, reference_class = \"malignant\") }"},{"path":[]},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"changed-0-4-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"vip 0.4.0","text":"NEWS file now follows Keep Changelog format. training data explicitly passed cases. Raised R version dependency >= 4.1.0 (introduction native piper operator |>). vi_permute function now uses yardstick; consequently, metric functions now conform yardstick metric argument names. var_fun argument vi_firm() deprecated; use new var_continuous var_categorical instead. explicit ice argument vi_firm() removed; really needed since can passed via ... argument. Removed magrittr imports; ’s easy enough just laod package need use R’s newer internal pipe operator. Tweaked examples. Tests based fastshap now check make sure ’s available. Suppress loading mixOmics tests. Switched lifecycle badge “maturing”, superseded, “experimental.” Fixed H2O URL vi_model.R. Removed unnecessary LazyData: true line DESCRIPTION file. Switched using markdown syntax roxygen2 comments.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"added-0-4-0","dir":"Changelog","previous_headings":"","what":"Added","title":"vip 0.4.0","text":"vi_model() now supports lightgbm models. Thanks @nipnipj suggestion (#146). permutation importance method (.e., function vi_permute()) now integrates uses yardstick performance metrics. list_metrics() gained additional smaller_is_better column indicating whether corresponding metric minimized (smaller_is_better = TRUE) maximized (smaller_is_better = FALSE); thanks @topedo. Additionally, column names now lower case. Added support partial least squares via mixOmics package (PR #129); thanks @topedo. Added support workflows parsnip packages tidymodels ecosystem (PR #128); thanks @topedo. New pkgdown site vignette based original R Journal article.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"removed-0-4-0","dir":"Changelog","previous_headings":"","what":"Removed","title":"vip 0.4.0","text":"Function add_sparklines() seems scope removed. Function vint() also seems scope slow implement practical problems; now, function likely live moreparty package.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"fixed-0-4-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"vip 0.4.0","text":"Fix model-based VI support mlr, mlr3, parsnip, workflows model fits.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-032","dir":"Changelog","previous_headings":"","what":"vip 0.3.2","title":"vip 0.3.2","text":"CRAN release: 2020-12-17","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"miscellaneous-0-3-2","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"vip 0.3.2","text":"Add tools/ .Rbuildignore.","code":""},{"path":[]},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"miscellaneous-0-3-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"vip 0.3.1","text":"Change http://spark.rstudio.com/mlib/ https://spark.rstudio.com/mlib/ NEWS.md. Remove unnecessary codecov.yml file.","code":""},{"path":[]},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"user-visable-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"User-visable changes","title":"vip 0.3.0","text":"Removed deprecated arguments vip(); particular, bar, width, alpha, color, fill, size, shape. Users instead rely mapping aesthetics arguments; see ?vip::vip details.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"vip 0.3.0","text":"Fixed couple bugs occurred using vi_model() glmnet package. particular, added new lamnda parameter specifying value penalty term use extracting estimated coefficients. equivalent s argument glmnet::coef(); name lambda chosen conflict arguments vi(). Additionally, vi_model() return absolute value estimated coefficients glmnet models like advertised, now fixed version (#103).","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"miscellaneous-0-3-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"vip 0.3.0","text":"Switched Travis-CI GitHub Actions continuous integration. Added CITATION file PDF-based vignette based published article R Journal (#109). Switch tibble::.tibble()—deprecated tibble 2.0.0—tibble::as_tibble() function calls (#101).","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-022","dir":"Changelog","previous_headings":"","what":"vip 0.2.2","title":"vip 0.2.2","text":"CRAN release: 2020-04-06","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"user-visible-changes-0-2-2","dir":"Changelog","previous_headings":"","what":"User-visible changes","title":"vip 0.2.2","text":"Importance column vi_model() longer contains “inner” names; accordance breaking changes tibble 3.0.0.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-021","dir":"Changelog","previous_headings":"","what":"vip 0.2.1","title":"vip 0.2.1","text":"CRAN release: 2020-01-20","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"enhancements-0-2-1","dir":"Changelog","previous_headings":"","what":"Enhancements","title":"vip 0.2.1","text":"Added support SHAP-based feature importance makes use recent fastshap package CRAN. use, simply call vi() vip() specify method = \"shap\", can just call vi_shap() directly (#87). Added support parsnip, mlr, mlr3 packages (#94). Added support \"mvr\" objects pls package (currently just calls caret::varImp()) (#35). \"lm\" method vi_model() gained new type argument allows users use either (1) raw coefficients features properly standardized (type = \"raw\"), (2) absolute value corresponding t- z-statistic (type = \"stat\", default) (#77). New function gen_friedman() simulating data Friedman 1 benchmark problem; see ?vip::gen_friedman details.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"user-visible-changes-0-2-1","dir":"Changelog","previous_headings":"","what":"User-visible changes","title":"vip 0.2.1","text":"vi_pdp() vi_ice() functions deprecated merged single new function called vi_firm(). Consequently, setting method = \"pdp\" method = \"ice\" also deprecated; use method = \"firm\" instead. metric pred_wrapper arguments vi_permute() longer optional. vip() function gained new argument, geom, specifying type plot construct. Current options geom = \"col\" (default), geom = \"point\", geom = \"boxplot\", geom = \"violin\" (latter two work permutation-based importance nsim > 1) (#79). Consequently, bar argument removed. vip() function gained two new arguments specifying aesthetics: mapping aesthetics (fixed aesthetics like color = \"red\"). Consequently, arguments color, fill, etc. removed (#80). example illustrating two changes given : vip() function gained new argument, include_type, defaults FALSE. TRUE, type variable importance computed included appropriate axis label. Set include_type = TRUE revert old behavior.","code":"# Load required packages library(ggplot2)  # for `aes_string()` function  # Load the sample data data(mtcars)  # Fit a linear regression model model <- lm(mpg ~ ., data = mtcars)  # Construct variable importance plots p1 <- vip(model) p2 <- vip(model, mapping = aes_string(color = \"Sign\")) p3 <- vip(model, type = \"dotplot\") p4 <- vip(model, type = \"dotplot\", mapping = aes_string(color = \"Variable\"),           aesthetics = list(size = 3)) grid.arrange(p1, p2, p3, p4, nrow = 2)"},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"miscellaneous-0-2-1","dir":"Changelog","previous_headings":"","what":"Miscellaneous","title":"vip 0.2.1","text":"Removed dependency ModelMetrics built-family performance metrics (metric_*()) now documented exported. See, example, ?vip::metric_rmse (#93). Switched tinytest framework (#82). Minor documentation improvements.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"bug-fixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"vip 0.2.1","text":"internal (.e., exported) get_feature_names() function better job \"nnet\" objects containing factors. also better job extracting feature names model objects containing \"formula\" component. vi_model() now works correctly \"glm\" objects non-Gaussian families (e.g., logistic regression) (#74). Added appropriate sparklyr version dependency (#59).","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-013","dir":"Changelog","previous_headings":"","what":"vip 0.1.3","title":"vip 0.1.3","text":"CRAN release: 2019-07-03","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"new-functions-0-1-3","dir":"Changelog","previous_headings":"","what":"New functions","title":"vip 0.1.3","text":"Removed warnings experimental functions. vi_permute() gained type argument (.e., type = \"difference\" type = \"ratio\"); argument can passed via vi() vip() well. add_sparklines() creates HTML widget display variable importance scores sparkline representation features effect (.e., partial dependence function) (#64). Added support Olden Garson algorithms neural networks fit using neuralnet, nnet, RSNNS packages (#28). Added support GLMNET models fit using glmnet package (without cross-validation).","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"breaking-changes-0-1-3","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"vip 0.1.3","text":"pred_fun argument vi_permute() changed pred_wrapper. FUN argument vi(), vi_pdp(), vi_ice() changed var_fun. predicted class probabilities reference class required (numeric vector) binary classification metric = \"auc\" metric = \"logloss\".","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"minor-changes-0-1-3","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"vip 0.1.3","text":"vi_permute() gained new logical keep argument. TRUE (default), raw permutation scores nsim repetitions (provided nsim > 1) stored attribute called \"raw_scores\". vip() gained new logical arguments all_permutations jitter help visualize raw permutation scores nsim repetitions (provided nsim > 1). can now pass type argument vi_permute() specifying compare baseline permuted performance metrics. Current choices \"difference\" (default) \"ratio\". Improved documentation (especially vi_permute() vi_model()). Results vi_model(), vi_pdp(), vi_ice(), vi_permute() now class \"vi\", making easier plot vip().","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-012","dir":"Changelog","previous_headings":"","what":"vip 0.1.2","title":"vip 0.1.2","text":"CRAN release: 2018-09-30 Added nsim argument vi_permute() reducing sampling variability induced permuting predictor (#36). Added sample_size sample_frac arguments vi_permute() reducing size training sample every Monte Carlo repetition (#41). Greatly improved documentation vi_model() various objects supports. New argument rank, defaults FALSE, available vi() (#55). Added support Spark (G)LMs. vi() now generic makes adding new methods easier (e.g., support DataRobot models). Bug fixes.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-011","dir":"Changelog","previous_headings":"","what":"vip 0.1.1","title":"vip 0.1.1","text":"CRAN release: 2018-09-27 Fixed bug get_feature_names.ranger() s.t. never returns NULL; either returns feature names throws error recovered model object (#43). Added pkgdown site: https://github.com/koalaverse/vip. Changed truncate_feature_names argument vi() abbreviate_feature_names abbreviates feature names, rather just truncating . Added CRAN-related badges (#32). New generic vi_permute() constructing permutation-based variable importance scores (#19). Fixed bug unnecessary error check vint() (#38). New vignette using vip unsupported models (using Keras API TensorFlow example). Added basic sparklyr support.","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-010","dir":"Changelog","previous_headings":"","what":"vip 0.1.0","title":"vip 0.1.0","text":"CRAN release: 2018-06-15 Added support XGBoost models (.e., objects class \"xgb.booster\"). Added support ranger models (.e., objects class \"ranger\"). Added support random forest models party package (.e., objects class \"RandomForest\"). vip() gained new argument, num_features, specifying many variable importance scores plot. default set 10. . changed _ argument names. vi() gained three new arguments: truncate_feature_names (truncating feature names returned tibble), sort (logical argument specifying whether resulting variable importance scores sorted), decreasing (logical argument specifying whether variable importance scores sorted decreasing order). vi_model.lm(), hence vi(), contains additional column called Sign contains sign original coefficients (#27). vi() gained new argument, scale, scaling variable importance scores largest 100. Default FALSE (#24). vip() gained two new arguments, size shape, controlling size shape points whenever bar = FALSE (#9). Added support \"H2OBinomialModel\", \"H2OMultinomialModel\", , \"H2ORegressionModel\" objects (#8).","code":""},{"path":"https://koalaverse.github.io/vip/news/index.html","id":"vip-001","dir":"Changelog","previous_headings":"","what":"vip 0.0.1","title":"vip 0.0.1","text":"Initial release.","code":""}]
